<div class="page animate-fade-in">
  <div class="page-header">
    <span class="badge badge-indigo">Hamming(7,4)</span>
    <h1 class="page-title">Код Хэмминга</h1>
    <p class="page-desc">
      Линейный блочный код, исправляющий одиночные ошибки (SEC). Изобретён Ричардом Хэммингом в 1950 году.
      Код Хэмминга (7,4) кодирует 4 бита данных в 7-битное кодовое слово, добавляя 3 бита чётности.
      Минимальное расстояние Хэмминга d<sub>min</sub> = 3.
    </p>
  </div>

  <!-- ═══════ Explainer: Что это простыми словами ═══════ -->
  <div class="explainer">
    <h4>Что это значит простыми словами?</h4>
    <p>
      Представьте, что вы отправляете SMS другу, но телефонная вышка иногда «портит» сигнал.
      Вы отправили <code>1011</code>, а друг получил <code>1<strong>1</strong>11</code> — второй бит «перевернулся».
      Друг не знает, что сообщение повреждено, и прочитает неправильные данные.
    </p>
    <p>
      <strong>Код Хэмминга</strong> решает эту проблему. Перед отправкой мы добавляем к нашим 4 битам
      ещё 3 <strong>контрольных бита</strong> (итого 7 бит). Эти контрольные биты устроены так хитро, что получатель может:
    </p>
    <ul>
      <li><strong>Обнаружить</strong>, что произошла ошибка (один бит изменился).</li>
      <li><strong>Найти</strong> точную позицию ошибки.</li>
      <li><strong>Исправить</strong> ошибку — перевернуть бит обратно. Без повторной передачи!</li>
    </ul>
    <p>
      Это работает для <strong>одной</strong> ошибки в блоке из 7 бит. Если ошибок две или больше — код может ошибиться сам.
      Но для многих реальных каналов (оперативная память, спутниковая связь) одиночные ошибки — самый частый случай.
    </p>
  </div>

  <div class="explainer">
    <h4>Зачем вообще нужна коррекция ошибок?</h4>
    <p>
      В реальном мире данные постоянно повреждаются:
    </p>
    <ul>
      <li><strong>Оперативная память (RAM)</strong> — космические лучи переворачивают биты (примерно 1 ошибка на 1 ГБ в час). Серверы используют ECC-память на основе кода Хэмминга.</li>
      <li><strong>Жёсткие диски и SSD</strong> — физический износ создаёт ошибки чтения.</li>
      <li><strong>Беспроводная связь</strong> — помехи от других устройств, отражения сигнала.</li>
      <li><strong>Космическая связь</strong> — слабый сигнал + помехи на миллионах километров.</li>
    </ul>
    <p>
      Без кодов коррекции нам пришлось бы просить отправить данные заново каждый раз — это медленно,
      а иногда невозможно (например, зонд Voyager уже улетел на 24 млрд км).
    </p>
  </div>

  <div class="explainer">
    <h4>Ключевые термины — от самых основ</h4>
    <ul>
      <li><strong>Бит</strong> — минимальная единица информации. Может принимать только два значения: <code>0</code> или <code>1</code>.
        Вся цифровая информация (текст, фото, видео) хранится в виде битов.</li>
      <li><strong>Байт</strong> — группа из 8 бит. Может хранить число от 0 до 255. Один символ текста = 1 байт.</li>
      <li><strong>Кодовое слово</strong> — блок данных вместе с добавленными контрольными битами. В нашем случае: 4 бита данных + 3 контрольных = 7 бит.</li>
      <li><strong>Блочный код</strong> — данные делятся на блоки фиксированной длины, каждый кодируется отдельно.
        Хэмминг(7,4) — это блочный код: берём блок из 4 бит, превращаем в блок из 7 бит.</li>
      <li><strong>Скорость кода R</strong> — отношение полезных данных ко всему кодовому слову. R = 4/7 &asymp; 0.57.
        То есть 57% кодового слова — это наши данные, а 43% — «накладные расходы» на защиту от ошибок.</li>
      <li><strong>XOR (&oplus;)</strong> — операция «исключающее ИЛИ». Правила просты: одинаковые биты дают 0, разные — 1.
        <div class="example-box">0 &oplus; 0 = 0   (оба одинаковые → 0)
0 &oplus; 1 = 1   (разные → 1)
1 &oplus; 0 = 1   (разные → 1)
1 &oplus; 1 = 0   (оба одинаковые → 0)</div>
        Важное свойство: <code>a &oplus; a = 0</code> (любое число XOR с самим собой = 0), и <code>a &oplus; 0 = a</code>.</li>
      <li><strong>Чётность</strong> — количество единиц в наборе битов: чётное или нечётное. Например, в <code>1011</code> три единицы — нечётное.
        Бит чётности делает число единиц чётным. XOR всех битов = 0 при чётном числе единиц.</li>
      <li><strong>Расстояние Хэмминга</strong> — количество позиций, в которых два слова различаются.
        <div class="example-box">1011 и 1001: различаются в позиции 2 → расстояние = 1
1011 и 0110: различаются в позициях 1, 2, 3, 4 → расстояние = 4</div>
        Минимальное расстояние кода (d<sub>min</sub>) = наименьшее расстояние между любыми двумя допустимыми кодовыми словами. Для Хэмминга(7,4) d<sub>min</sub> = 3.</li>
      <li><strong>Линейный код</strong> — код, в котором XOR двух допустимых кодовых слов тоже является допустимым кодовым словом. Это позволяет описывать код с помощью матриц.</li>
    </ul>
  </div>

  <!-- ═══════ STEP 1: Input ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">1</div>
      <div class="step-label">Входные данные — 4 бита</div>
    </div>

    <p class="section-desc">
      Кликните на любой бит, чтобы переключить его значение. Или используйте кнопки ниже.
    </p>

    <div class="bit-row">
      @for (bit of dataBits(); track $index; let i = $index) {
        <div class="bit-input-group">
          <span class="bit-label">d{{ i + 1 }}</span>
          <div class="bit-cell" [class.bit-0]="bit === 0" [class.bit-1]="bit === 1"
               (click)="toggleDataBit(i)">
            {{ bit }}
          </div>
        </div>
      }
    </div>

    <div class="action-row">
      <button class="btn btn-sm" (click)="randomData()">
        <svg width="14" height="14" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 12c0-1.232-.046-2.453-.138-3.662a4.006 4.006 0 00-3.7-3.7 48.678 48.678 0 00-7.324 0 4.006 4.006 0 00-3.7 3.7c-.017.22-.032.441-.046.662M19.5 12l3-3m-3 3l-3-3m-12 3c0 1.232.046 2.453.138 3.662a4.006 4.006 0 003.7 3.7 48.656 48.656 0 007.324 0 4.006 4.006 0 003.7-3.7c.017-.22.032-.441.046-.662M4.5 12l3 3m-3-3l-3 3"/>
        </svg>
        Случайные данные
      </button>
      <button class="btn btn-sm" (click)="setDataBits([0,0,0,0])">Все 0</button>
      <button class="btn btn-sm" (click)="setDataBits([1,1,1,1])">Все 1</button>
    </div>
  </section>

  <!-- ═══════ Explainer: Почему степени двойки ═══════ -->
  <div class="explainer-why">
    <h4>Почему контрольные биты стоят в позициях 1, 2, 4 — именно степени двойки?</h4>
    <p>
      Это <strong>ключевая гениальная идея</strong> Ричарда Хэмминга. Чтобы её понять, нужно сделать один простой шаг:
      записать номера всех позиций <strong>в двоичной системе</strong>.
    </p>
    <div class="example-box">Позиция:   1     2     3     4     5     6     7
Двоичная: 001   010   011   100   101   110   111
           ↑     ↑           ↑
        степень  степень   степень
        двойки   двойки    двойки
        (2⁰=1)  (2¹=2)    (2²=4)</div>
    <p>
      Заметьте: у степеней двойки в двоичном виде стоит ровно <strong>одна единица</strong>.
      Позиция 1 = 001 (единица только в разряде 0), позиция 2 = 010 (только в разряде 1), позиция 4 = 100 (только в разряде 2).
    </p>
    <p>
      Теперь назначим каждому контрольному биту «свой» двоичный разряд:
    </p>
    <ul>
      <li><strong>p1</strong> (позиция 1 = 00<strong>1</strong>) — «следит» за разрядом 0. Проверяет все позиции, где <strong>самый правый бит = 1</strong>: позиции 1, 3, 5, 7.
        <div class="example-box">001 (=1) ✓   010 (=2) ✗   011 (=3) ✓   100 (=4) ✗   101 (=5) ✓   110 (=6) ✗   111 (=7) ✓
  ↑ = 1              ↑ = 0              ↑ = 1              ↑ = 0              ↑ = 1              ↑ = 0              ↑ = 1</div></li>
      <li><strong>p2</strong> (позиция 2 = 0<strong>1</strong>0) — «следит» за разрядом 1. Проверяет все позиции, где <strong>средний бит = 1</strong>: позиции 2, 3, 6, 7.</li>
      <li><strong>p4</strong> (позиция 4 = <strong>1</strong>00) — «следит» за разрядом 2. Проверяет все позиции, где <strong>самый левый бит = 1</strong>: позиции 4, 5, 6, 7.</li>
    </ul>
    <p>
      <strong>Почему это работает?</strong> Допустим, ошибка произошла в позиции 5. Двоичное представление: 5 = <code>101</code>.
      Единицы стоят в разрядах 0 и 2 → «сработают» проверки p1 (разряд 0) и p4 (разряд 2), а проверка p2 (разряд 1) не сработает.
    </p>
    <div class="example-box">Ошибка в позиции 5 (= 101₂):
  Разряд 0 = 1 → проверка p1 сработала (s1 = 1)
  Разряд 1 = 0 → проверка p2 НЕ сработала (s2 = 0)
  Разряд 2 = 1 → проверка p4 сработала (s4 = 1)

Синдром = (s4, s2, s1) = (1, 0, 1) = 101₂ = 5₁₀
→ Ошибка в позиции 5! Мы нашли её без повторной передачи!</div>
    <p>
      Каждая из 7 позиций имеет <strong>уникальный</strong> двоичный код (от 001 до 111),
      и каждая уникально активирует свой набор проверок. Поэтому синдром однозначно указывает на позицию ошибки.
    </p>
  </div>

  <div class="explainer">
    <h4>Что такое «группы чётности» и как вычисляются контрольные биты?</h4>
    <p>
      Каждый контрольный бит <code>p<sub>k</sub></code> отвечает за свою <strong>группу позиций</strong>.
      Он выбирается так, чтобы XOR всех битов в группе давал 0 (чётное число единиц в группе).
    </p>
    <p>
      Рассмотрим конкретный пример. Пусть данные = <code>1 0 1 1</code>. Они встают в позиции 3, 5, 6, 7:
    </p>
    <div class="example-box">Позиция:  1    2    3    4    5    6    7
Содержит: p1   p2   d1   p4   d2   d3   d4
Данные:    ?    ?    1    ?    0    1    1

Вычисляем p1 (покрывает позиции 1, 3, 5, 7):
  p1 ⊕ d1 ⊕ d2 ⊕ d4 = 0
  p1 ⊕  1 ⊕  0 ⊕  1 = 0
  p1 ⊕ 0 = 0  →  p1 = 0

Вычисляем p2 (покрывает позиции 2, 3, 6, 7):
  p2 ⊕ d1 ⊕ d3 ⊕ d4 = 0
  p2 ⊕  1 ⊕  1 ⊕  1 = 0
  p2 ⊕ 1 = 0  →  p2 = 1

Вычисляем p4 (покрывает позиции 4, 5, 6, 7):
  p4 ⊕ d2 ⊕ d3 ⊕ d4 = 0
  p4 ⊕  0 ⊕  1 ⊕  1 = 0
  p4 ⊕ 0 = 0  →  p4 = 0

Результат: 0 1 1 0 0 1 1 — кодовое слово из 7 бит.</div>
    <p>
      При передаче, если XOR группы стал равен 1 — значит, в этой группе кто-то изменился.
      Комбинация «сработавших» групп точно указывает, кто именно.
    </p>
  </div>

  <!-- ═══════ STEP 2: Encoding Process ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">2</div>
      <div class="step-label">Кодирование — вычисление битов чётности</div>
    </div>

    <p class="section-desc">
      Биты чётности располагаются в позициях, являющихся степенями двойки: 1, 2, 4.
      Каждый бит чётности покрывает определённую группу позиций. Позиция покрывается битом
      чётности <code>p<sub>k</sub></code>, если в двоичном представлении номера позиции бит k равен 1.
    </p>

    <!-- Position assignment table -->
    <div class="pos-table">
      <div class="pos-header">
        <div class="pos-cell pos-label">Позиция</div>
        @for (i of [1,2,3,4,5,6,7]; track i) {
          <div class="pos-cell">{{ i }}</div>
        }
      </div>
      <div class="pos-row">
        <div class="pos-cell pos-label">Двоичная</div>
        @for (i of [1,2,3,4,5,6,7]; track i) {
          <div class="pos-cell mono">{{ i.toString(2).padStart(3, '0') }}</div>
        }
      </div>
      <div class="pos-row">
        <div class="pos-cell pos-label">Тип</div>
        @for (i of [1,2,3,4,5,6,7]; track i) {
          <div class="pos-cell" [class.type-parity]="isPowerOfTwo(i)" [class.type-data]="!isPowerOfTwo(i)">
            {{ getPositionType(i) }}
          </div>
        }
      </div>
    </div>

    <!-- Encoding steps -->
    <div class="encoding-steps">
      @for (step of encodingSteps(); track step.parityBit) {
        <div class="encoding-step"
             (mouseenter)="highlightParityGroup.set(step.parityBit)"
             (mouseleave)="highlightParityGroup.set(null)">
          <div class="step-parity-badge" [class]="'parity-' + step.parityBit">
            p{{ step.parityBit }}
          </div>
          <div class="step-detail">
            <div class="step-positions">
              Покрывает позиции:
              @for (pos of step.positions; track pos) {
                <span class="pos-tag" [class.highlight]="highlightParityGroup() === step.parityBit && isInParityGroup(pos, step.parityBit)">{{ pos }}</span>
              }
            </div>
            <code class="step-formula">{{ step.explanation }}</code>
          </div>
        </div>
      }
    </div>
  </section>

  <!-- ═══════ STEP 3: Encoded Codeword ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">3</div>
      <div class="step-label">Закодированное слово</div>
    </div>

    <p class="section-desc">
      Результат кодирования — 7-битное кодовое слово. Жёлтые ячейки — биты чётности, голубые — данные.
    </p>

    <div class="codeword-display">
      @for (info of bitInfos(); track info.position; let i = $index) {
        <div class="cw-bit-group">
          <span class="cw-pos">{{ info.position }}</span>
          <div class="bit-cell"
               [class.bit-parity]="info.type === 'parity'"
               [class.bit-0]="info.type === 'data' && info.value === 0"
               [class.bit-1]="info.type === 'data' && info.value === 1"
               [class.highlight-group]="highlightParityGroup() !== null && isInParityGroup(info.position, highlightParityGroup()!)">
            {{ info.value }}
          </div>
          <span class="cw-label" [class.label-parity]="info.type === 'parity'">
            {{ info.label }}{{ info.type === 'parity' ? '' : (info.position) }}
          </span>
        </div>
      }
    </div>
  </section>

  <!-- ═══════ Explainer: Проверочная матрица H ═══════ -->
  <div class="explainer">
    <h4>Что такое проверочная матрица H и зачем она нужна?</h4>
    <p>
      До сих пор мы считали каждую проверку чётности отдельно. Но есть элегантный способ
      <strong>записать все три проверки одной формулой</strong> — через матрицу H.
    </p>
    <p>
      Матрица H — это таблица 3&times;7, где <strong>столбцы</strong> — это номера позиций 1..7,
      записанные в двоичном виде вертикально (снизу вверх):
    </p>
    <div class="example-box">           Поз.1  Поз.2  Поз.3  Поз.4  Поз.5  Поз.6  Поз.7
H =  s4: [  0      0      0      1      1      1      1  ]
     s2: [  0      1      1      0      0      1      1  ]
     s1: [  1      0      1      0      1      0      1  ]

Столбец 5: (1,0,1) = 101₂ = 5 ✓
Столбец 3: (0,1,1) = 011₂ = 3 ✓</div>
    <p>
      <strong>Как работает:</strong> Чтобы проверить принятое слово r, вычисляем синдром <code>S = H &middot; r (mod 2)</code>.
      Это просто одна операция — <strong>умножение матрицы на вектор</strong>:
    </p>
    <div class="example-box">Пример: получили r = [0, 1, 1, 0, 0, 1, 1] (без ошибок)

s4 = 0&middot;0 ⊕ 0&middot;1 ⊕ 0&middot;1 ⊕ 1&middot;0 ⊕ 1&middot;0 ⊕ 1&middot;1 ⊕ 1&middot;1 = 0⊕0⊕0⊕0⊕0⊕1⊕1 = 0
s2 = 0&middot;0 ⊕ 1&middot;1 ⊕ 1&middot;1 ⊕ 0&middot;0 ⊕ 0&middot;0 ⊕ 1&middot;1 ⊕ 1&middot;1 = 0⊕1⊕1⊕0⊕0⊕1⊕1 = 0
s1 = 1&middot;0 ⊕ 0&middot;1 ⊕ 1&middot;1 ⊕ 0&middot;0 ⊕ 1&middot;0 ⊕ 0&middot;1 ⊕ 1&middot;1 = 0⊕0⊕1⊕0⊕0⊕0⊕1 = 0

Синдром S = (0, 0, 0) = 0 → Ошибок нет! ✓</div>
    <p>
      Теперь допустим ошибка в позиции 5: бит 0 стал 1, r = [0, 1, 1, 0, <strong>1</strong>, 1, 1]:
    </p>
    <div class="example-box">s4 = 0⊕0⊕0⊕0⊕1⊕1⊕1 = 1   (было 0, стало 1 — изменилось!)
s2 = 0⊕1⊕1⊕0⊕0⊕1⊕1 = 0   (не изменилось)
s1 = 0⊕0⊕1⊕0⊕1⊕0⊕1 = 1   (изменилось!)

Синдром S = (1, 0, 1) = 101₂ = 5 → Ошибка в позиции 5!</div>
    <p>
      Матрица H — это компактная запись всех проверок. Один столбец = одна позиция.
      Если в позиции ошибка, к синдрому «добавляется» (XOR) соответствующий столбец — и синдром становится равен номеру этой позиции.
    </p>
  </div>

  <!-- ═══════ STEP 4: Parity Check Matrix ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">4</div>
      <div class="step-label">Проверочная матрица H</div>
    </div>

    <p class="section-desc">
      Матрица H определяет проверочные соотношения. Каждая строка соответствует одному биту синдрома.
      Столбцы — это двоичные представления номеров позиций (от 1 до 7). Синдром вычисляется как
      <code>S = H &middot; r<sup>T</sup></code>, где r — принятое слово.
    </p>

    <div class="matrix-container">
      <div class="matrix-wrapper">
        <div class="matrix-bracket left">H =</div>
        <div class="matrix-grid">
          <div class="matrix-col-labels">
            <div class="matrix-spacer"></div>
            @for (label of posLabels; track label) {
              <div class="matrix-col-label">{{ label }}</div>
            }
          </div>
          @for (row of parityCheckMatrix; track $index; let ri = $index) {
            <div class="matrix-row">
              <div class="matrix-row-label">{{ hLabels[ri] }}</div>
              @for (cell of row; track $index; let ci = $index) {
                <div class="matrix-cell"
                     [class.cell-1]="cell === 1"
                     [class.cell-0]="cell === 0"
                     [class.cell-highlight]="highlightParityGroup() === parityCheckMatrix[ri][ci] * (ri === 0 ? 1 : ri === 1 ? 2 : 4)">
                  {{ cell }}
                </div>
              }
            </div>
          }
        </div>
      </div>
    </div>
  </section>

  <!-- ═══════ STEP 5: Error Injection ═══════ -->
  <section class="card section error-section">
    <div class="step-indicator">
      <div class="step-num">5</div>
      <div class="step-label">Инъекция ошибки</div>
    </div>

    <p class="section-desc">
      Кликните на любой бит закодированного слова, чтобы инвертировать его — это симулирует
      ошибку при передаче. Синдром сразу покажет, где произошла ошибка.
    </p>

    <div class="codeword-display">
      @for (bit of received(); track $index; let i = $index) {
        <div class="cw-bit-group">
          <span class="cw-pos">{{ useExtended() ? i : i + 1 }}</span>
          <div class="bit-cell"
               [class.bit-error]="errorPosition() === i"
               [class.bit-0]="errorPosition() !== i && bit === 0"
               [class.bit-1]="errorPosition() !== i && bit === 1"
               (click)="injectError(i)">
            {{ bit }}
          </div>
        </div>
      }
    </div>

    <div class="action-row">
      <button class="btn btn-danger btn-sm" (click)="randomError()">
        <svg width="14" height="14" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 13.5l10.5-11.25L12 10.5h8.25L9.75 21.75 12 13.5H3.75z"/>
        </svg>
        Случайная ошибка
      </button>
      <button class="btn btn-sm" (click)="clearError()">Убрать ошибку</button>
    </div>
  </section>

  <!-- ═══════ Explainer: Что такое синдром ═══════ -->
  <div class="explainer">
    <h4>Что такое синдром? Пошаговый разбор</h4>
    <p>
      Слово <strong>«синдром»</strong> пришло из медицины — это набор симптомов, указывающих на болезнь.
      В теории кодирования синдром — это <strong>набор результатов проверок</strong>, указывающих на ошибку.
    </p>
    <p>
      Синдром — это три бита: <code>s1</code>, <code>s2</code>, <code>s4</code>.
      Каждый бит — результат одной проверки чётности:
    </p>
    <ul>
      <li><code>s1</code> = XOR всех битов, покрываемых p1 (позиции 1, 3, 5, 7). Если 0 — в этой группе всё в порядке. Если 1 — в группе есть ошибка.</li>
      <li><code>s2</code> = XOR всех битов, покрываемых p2 (позиции 2, 3, 6, 7).</li>
      <li><code>s4</code> = XOR всех битов, покрываемых p4 (позиции 4, 5, 6, 7).</li>
    </ul>
    <p>
      <strong>Как читать синдром:</strong>
    </p>
    <ul>
      <li>Все три = 0 → <code>(0,0,0)</code> → 0 → <strong>ошибок нет</strong>.</li>
      <li>Хоть один ≠ 0 → составляем число <code>(s4, s2, s1)</code> → это <strong>номер позиции ошибки</strong>.</li>
    </ul>
    <div class="example-box">Полный пример от начала до конца:

1. Данные: d1=1, d2=0, d3=1, d4=1
2. Кодовое слово: [0, 1, 1, 0, 0, 1, 1]  (после расчёта p1=0, p2=1, p4=0)
3. При передаче бит в позиции 3 перевернулся: [0, 1, 0, 0, 0, 1, 1]
                                                           ↑ было 1, стало 0

4. Получатель вычисляет синдром:
   s1 = поз.1 ⊕ поз.3 ⊕ поз.5 ⊕ поз.7 = 0 ⊕ 0 ⊕ 0 ⊕ 1 = 1
   s2 = поз.2 ⊕ поз.3 ⊕ поз.6 ⊕ поз.7 = 1 ⊕ 0 ⊕ 1 ⊕ 1 = 1
   s4 = поз.4 ⊕ поз.5 ⊕ поз.6 ⊕ поз.7 = 0 ⊕ 0 ⊕ 1 ⊕ 1 = 0

5. Синдром = (s4, s2, s1) = (0, 1, 1) = 011₂ = 3
   → Ошибка в позиции 3!

6. Инвертируем бит 3: 0 → 1
   Исправленное слово: [0, 1, 1, 0, 0, 1, 1] ← совпадает с отправленным! ✓</div>
  </div>

  <!-- ═══════ STEP 6: Syndrome Calculation ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">6</div>
      <div class="step-label">Вычисление синдрома</div>
    </div>

    <p class="section-desc">
      Синдром S = (s1, s2, s4) вычисляется XOR-ом битов в каждой группе чётности.
      Если S = 0 — ошибок нет. Иначе, значение синдрома в десятичной форме указывает на позицию ошибки.
    </p>

    <div class="syndrome-steps">
      @for (step of syndromeSteps(); track step.parityBit) {
        <div class="syndrome-step">
          <code class="syndrome-formula">{{ step.explanation }}</code>
          <span class="syndrome-result" [class.result-ok]="step.xorResult === 0" [class.result-err]="step.xorResult === 1">
            {{ step.xorResult }}
          </span>
        </div>
      }
    </div>

    <div class="syndrome-summary">
      <div class="syndrome-value">
        <span class="syn-label">Синдром S =</span>
        <span class="syn-bits">({{ syndrome().s1 }}, {{ syndrome().s2 }}, {{ syndrome().s4 }})</span>
        <span class="syn-equals">=</span>
        <span class="syn-decimal" [class.no-error]="syndrome().value === 0" [class.has-error]="syndrome().value !== 0">
          {{ syndrome().value }}
        </span>
      </div>
      @if (syndrome().value === 0) {
        <div class="syndrome-message ok">Синдром равен 0 — ошибок не обнаружено</div>
      } @else {
        <div class="syndrome-message error">
          Синдром = {{ syndrome().value }} → ошибка в позиции {{ syndrome().value }}
        </div>
      }
    </div>
  </section>

  <!-- ═══════ Explainer: Как исправить ошибку ═══════ -->
  <div class="explainer">
    <h4>Как происходит исправление?</h4>
    <p>
      Исправить ошибку невероятно просто — нужно <strong>инвертировать один бит</strong>:
    </p>
    <ul>
      <li>Синдром сказал «ошибка в позиции N» → переворачиваем бит в позиции N.</li>
      <li>Если бит был 0 → ставим 1. Если был 1 → ставим 0.</li>
      <li>Готово! Кодовое слово восстановлено.</li>
    </ul>
    <p>
      Математически: <code>исправленный_бит = полученный_бит &oplus; 1</code>.
      XOR с единицей инвертирует бит (0&oplus;1=1, 1&oplus;1=0).
    </p>
    <p>
      <strong>Ограничение:</strong> если ошибок было <strong>две или больше</strong>, синдром покажет неправильную позицию
      (или вообще 0, ошибочно сообщив, что ошибок нет). Код Хэмминга(7,4) гарантированно работает только при ≤1 ошибке на блок.
    </p>
  </div>

  <!-- ═══════ STEP 7: Error Correction ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">7</div>
      <div class="step-label">Исправление ошибки</div>
    </div>

    <p class="section-desc">
      Для исправления достаточно инвертировать бит в позиции, указанной синдромом.
      После исправления кодовое слово совпадает с исходным.
    </p>

    <div class="correction-result">
      <div class="correction-message" [class.ok]="syndrome().value === 0" [class.corrected]="syndrome().value !== 0">
        {{ corrected().message }}
      </div>

      <div class="codeword-display">
        @for (bit of corrected().word; track $index; let i = $index) {
          <div class="cw-bit-group">
            <span class="cw-pos">{{ useExtended() ? i : i + 1 }}</span>
            <div class="bit-cell"
                 [class.bit-corrected]="corrected().errorAt === i"
                 [class.bit-0]="corrected().errorAt !== i && bit === 0"
                 [class.bit-1]="corrected().errorAt !== i && bit === 1">
              {{ bit }}
            </div>
          </div>
        }
      </div>

      @if (syndrome().value !== 0) {
        <div class="comparison">
          <div class="comp-row">
            <span class="comp-label">Отправлено:</span>
            <code class="comp-bits">{{ encoded().join('') }}</code>
          </div>
          <div class="comp-row">
            <span class="comp-label">Получено:</span>
            <code class="comp-bits error-bits">{{ received().join('') }}</code>
          </div>
          <div class="comp-row">
            <span class="comp-label">Исправлено:</span>
            <code class="comp-bits ok-bits">{{ corrected().word.join('') }}</code>
          </div>
        </div>
      }
    </div>
  </section>

  <!-- ═══════ Theory Section ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">i</div>
      <div class="step-label">Теоретическая справка</div>
    </div>

    <div class="explainer" style="margin-bottom: 24px;">
      <h4>Линейный код — почему это важно?</h4>
      <p>
        Код называется <strong>линейным</strong>, если XOR любых двух допустимых кодовых слов тоже является допустимым кодовым словом.
        Звучит абстрактно, но это даёт огромные практические преимущества:
      </p>
      <ul>
        <li><strong>Нулевой вектор</strong> (все нули) — всегда допустимое кодовое слово. Можно использовать как «начало отсчёта».</li>
        <li>Код полностью описывается <strong>двумя матрицами</strong>:
          <ul>
            <li><strong>G (порождающая)</strong> — для кодирования: <code>кодовое_слово = данные &times; G</code></li>
            <li><strong>H (проверочная)</strong> — для декодирования: <code>синдром = H &times; принятое_слово</code></li>
          </ul>
        </li>
        <li>Кодирование и декодирование — просто <strong>умножение на матрицу</strong>. Это очень быстро в железе (несколько тактов процессора).</li>
        <li>Для проверки минимального расстояния достаточно проверить <strong>веса</strong> кодовых слов (количество единиц), а не сравнивать все пары.</li>
      </ul>
      <div class="example-box">Пример линейности:
Кодовое слово 1: 0 1 1 0 0 1 1  (данные 1011)
Кодовое слово 2: 1 0 0 1 1 0 1  (данные 0101)

XOR (поразрядно): 1 1 1 1 1 1 0  — тоже допустимое кодовое слово!
                                     (данные 1011 ⊕ 0101 = 1110)</div>
    </div>

    <div class="theory-grid">
      <div class="theory-block">
        <h3>Параметры кода</h3>
        <div class="param-list">
          <div class="param"><span class="param-key">n (длина кода)</span><span class="param-val">7</span></div>
          <div class="param"><span class="param-key">k (инф. биты)</span><span class="param-val">4</span></div>
          <div class="param"><span class="param-key">r (проверочные)</span><span class="param-val">3</span></div>
          <div class="param"><span class="param-key">d<sub>min</sub></span><span class="param-val">3</span></div>
          <div class="param"><span class="param-key">Скорость кода R</span><span class="param-val">4/7 ≈ 0.571</span></div>
        </div>
      </div>

      <div class="theory-block">
        <h3>Возможности</h3>
        <div class="capability-list">
          <div class="capability ok-cap">Обнаружение до 2 ошибок</div>
          <div class="capability ok-cap">Исправление 1 ошибки</div>
          <div class="capability warn-cap">Не может исправить 2+ ошибки</div>
        </div>
      </div>

      <div class="theory-block">
        <h3>Формула Хэмминга</h3>
        <p class="theory-text">
          Для кода Хэмминга (n, k) выполняется:
        </p>
        <div class="formula">
          2<sup>r</sup> ≥ n + 1, где r = n − k
        </div>
        <p class="theory-text" style="margin-top: 12px;">
          Для r=3: 2³ = 8 ≥ 7 + 1 = 8 ✓
        </p>
      </div>

      <div class="theory-block">
        <h3>Расширенный код Хэмминга</h3>
        <p class="theory-text">
          Добавление общего бита чётности p0 даёт код (8,4) с d<sub>min</sub> = 4.
          Это позволяет исправлять 1 ошибку и обнаруживать 2 (SEC-DED).
        </p>
      </div>
    </div>
  </section>
</div>
