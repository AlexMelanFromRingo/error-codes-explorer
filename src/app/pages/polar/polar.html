<div class="page animate-fade-in">
  <div class="page-header">
    <span class="badge badge-emerald">Polar Codes</span>
    <h1 class="page-title">Полярные коды</h1>
    <p class="page-desc">
      Первые коды, для которых доказано достижение пропускной способности канала (Эрдал Арыкан, 2009).
      Используют феномен поляризации каналов: при рекурсивном комбинировании каналы
      «поляризуются» в полностью надёжные и полностью ненадёжные. Стандарт 5G NR для управляющих каналов.
    </p>
  </div>

  <!-- ═══════ Explainer: Простыми словами ═══════ -->
  <div class="explainer">
    <h4>Простыми словами — что такое полярные коды?</h4>
    <p>
      Представьте, что у вас есть 8 одинаковых, слегка шумных каналов связи.
      Каждый канал передаёт 1 бит, но иногда ошибается (например, с вероятностью 10%).
    </p>
    <p>
      Полярный код делает хитрый трюк: он «перемешивает» каналы через операции XOR.
      После перемешивания каналы <strong>поляризуются</strong> — расходятся к двум крайностям:
    </p>
    <ul>
      <li><strong>Хорошие каналы</strong> (почти идеальные) — ошибка почти невозможна. Через них отправляем данные.</li>
      <li><strong>Плохие каналы</strong> (почти бесполезные) — сплошной шум. Их «замораживаем» — ставим туда заранее известное значение (обычно 0).</li>
    </ul>
    <p>
      Декодер знает, какие каналы заморожены (их значения = 0), и использует эту информацию для восстановления данных из хороших каналов. Замороженные биты — это «бесплатная подсказка» для декодера.
    </p>
    <div class="example-box">Аналогия: У вас 8 телефонных линий с помехами.
Вы хитро соединяете их друг с другом и получаете:
  4 линии с отличным качеством → передаём данные
  4 линии с ужасным качеством → просто молчим (замораживаем)

Итого: передали 4 бита по 8 каналам. Скорость R = 4/8 = 0.5</div>
  </div>

  <div class="explainer">
    <h4>Чем полярные коды особенные?</h4>
    <p>
      Полярные коды — <strong>исторический прорыв</strong> в теории кодирования:
    </p>
    <ul>
      <li>Они были изобретены турецким профессором <strong>Эрдалом Арыканом</strong> в 2009 году.</li>
      <li>Это <strong>первые в истории</strong> коды, для которых математически <strong>доказано</strong>, что они достигают предела Шеннона (максимальной скорости безошибочной передачи).</li>
      <li>До этого LDPC и турбо-коды <em>приближались</em> к пределу, но формального доказательства не было.</li>
      <li>Полярные коды были приняты в стандарт <strong>5G NR</strong> для управляющих каналов (PDCCH, PUCCH).</li>
    </ul>
  </div>

  <div class="explainer-why">
    <h4>Что такое пропускная способность канала?</h4>
    <p>
      <strong>Пропускная способность C</strong> — максимальная скорость, при которой можно передавать данные
      через канал со сколь угодно малой вероятностью ошибки. Это фундаментальный предел, установленный теоремой Шеннона (1948).
    </p>
    <div class="example-box">Пример: Двоичный симметричный канал (BSC)
  Каждый бит может перевернуться с вероятностью p.

  При p = 0 (без ошибок): C = 1 бит/символ (идеально)
  При p = 0.1 (10% ошибок): C ≈ 0.53 бит/символ
  При p = 0.5 (случайный шум): C = 0 (передача невозможна)

Полярные коды доказуемо достигают C при N → ∞.</div>
  </div>

  <!-- ═══════ STEP 1: Channel Polarization ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">1</div>
      <div class="step-label">Поляризация каналов</div>
    </div>

    <div class="explainer">
      <h4>Что такое поляризация каналов? Пошаговый разбор на 2 каналах</h4>
      <p>
        Начнём с простейшего примера: 2 одинаковых канала, каждый ошибается с вероятностью p = 0.11.
      </p>
      <p>
        Вместо того чтобы посылать u<sub>1</sub> и u<sub>2</sub> напрямую, мы делаем преобразование:
      </p>
      <div class="example-box">Передаём:
  Канал 1: x₁ = u₁ ⊕ u₂  (XOR двух битов)
  Канал 2: x₂ = u₂         (второй бит без изменений)

Приёмник получает y₁ (версию x₁ с шумом) и y₂ (версию x₂ с шумом).</div>
      <p>
        Теперь посмотрим, что происходит при <strong>декодировании</strong> (биты декодируются по порядку: сначала u₁, потом u₂):
      </p>
      <ul>
        <li><strong>Декодирование u₁:</strong> Мы видим y₁ и y₂, но не знаем u₂. Нам нужно угадать u₁ = x₁ &oplus; u₂ по двум шумным наблюдениям — это <strong>сложнее</strong>, чем по одному. Вероятность ошибки для u₁ <strong>выросла</strong>: p<sup>−</sup> ≈ 0.20.</li>
        <li><strong>Декодирование u₂:</strong> Мы уже знаем u₁ (декодировали на предыдущем шаге). Значит, из y₁ мы можем восстановить x₂ = u₁ &oplus; x₁. Теперь у нас <strong>две</strong> независимые оценки u₂ (из y₁ и из y₂) — это <strong>легче</strong>. Вероятность ошибки для u₂ <strong>уменьшилась</strong>: p<sup>+</sup> ≈ 0.012.</li>
      </ul>
      <p>
        <strong>Итог:</strong> из двух одинаковых каналов (p=0.11 каждый) мы получили один плохой (p≈0.20) и один хороший (p≈0.012).
        Каналы «поляризовались»! При N → &infin; через log₂(N) уровней рекурсии <strong>все</strong> каналы уйдут к полюсам: или идеальные, или бесполезные.
      </p>
    </div>

    <div class="explainer-why">
      <h4>Параметр Бхаттачарьи Z(W) — «оценка качества» канала</h4>
      <p>
        <strong>Z(W)</strong> — число от 0 до 1, измеряющее <strong>ненадёжность</strong> виртуального канала:
      </p>
      <ul>
        <li><strong>Z = 0</strong> — идеальный канал, ошибок не бывает. Используем для передачи данных.</li>
        <li><strong>Z = 1</strong> — бесполезный канал, чистый шум. Замораживаем (ставим = 0).</li>
        <li><strong>Z = 0.5</strong> — «серединка», ненадёжный. Тоже замораживаем (лучше перестраховаться).</li>
      </ul>
      <div class="example-box">Пример для N=8 каналов (параметры Бхаттачарьи):
  u0: Z=0.99 (ужасный)  → замораживаем
  u1: Z=0.85 (плохой)   → замораживаем
  u2: Z=0.72 (плохой)   → замораживаем
  u3: Z=0.35 (средний)  → замораживаем
  u4: Z=0.18 (неплохой) → ДАННЫЕ ← K лучших
  u5: Z=0.09 (хороший)  → ДАННЫЕ
  u6: Z=0.03 (отличный) → ДАННЫЕ
  u7: Z=0.001 (почти идеальный) → ДАННЫЕ

Выбрали K=4 лучших канала для данных, остальные заморозили.</div>
      <p>
        Чем длиннее код (больше N), тем сильнее поляризация: каналы уходят ближе к 0 и 1, «серединки» почти не остаётся.
      </p>
    </div>

    <p class="section-desc">
      Параметры Бхаттачарьи Z(W) показывают надёжность каждого виртуального канала.
      Z = 0 — идеальный канал, Z = 1 — полностью ненадёжный.
      Лучшие K каналов используются для данных (зелёные), остальные «замораживаются» (серые).
    </p>

    <div class="channels-display">
      @for (ch of channels(); track ch.index) {
        <div class="channel-bar" [class.ch-info]="ch.type === 'info'" [class.ch-frozen]="ch.type === 'frozen'">
          <div class="bar-fill" [style.height.%]="ch.reliability * 100"></div>
          <span class="bar-label">u{{ ch.index }}</span>
          <span class="bar-type">{{ ch.type === 'info' ? 'инф.' : 'замор.' }}</span>
          <span class="bar-z">Z={{ ch.bhattacharyya.toFixed(3) }}</span>
        </div>
      }
    </div>

    <div class="channel-info">
      <span class="badge badge-emerald">Информ. каналы: {{ infoBitIndices().join(', ') }}</span>
      <span class="badge badge-amber">Замороженные: {{ frozenBitIndices().join(', ') }}</span>
    </div>
  </section>

  <!-- ═══════ Explainer: Произведение Кронекера ═══════ -->
  <div class="explainer">
    <h4>Что такое произведение Кронекера? Объяснение с нуля</h4>
    <p>
      <strong>Произведение Кронекера</strong> A &otimes; B — это способ «масштабирования» матрицы.
      Каждый элемент матрицы A <strong>заменяется на целую матрицу B</strong>, умноженную на этот элемент.
    </p>
    <p>
      Для полярных кодов базовая матрица:
      <code>F = [[1, 0], [1, 1]]</code> (матрица 2&times;2).
    </p>
    <div class="example-box">Шаг за шагом: F ⊗ F

Исходная F:  | 1  0 |
             | 1  1 |

Заменяем каждый элемент на блок:
  Элемент 1 (левый верх) = 1 → 1&middot;F = | 1 0 |
                                         | 1 1 |
  Элемент 0 (правый верх) = 0 → 0&middot;F = | 0 0 |
                                          | 0 0 |
  Элемент 1 (левый низ) = 1 → 1&middot;F = | 1 0 |
                                        | 1 1 |
  Элемент 1 (правый низ) = 1 → 1&middot;F = | 1 0 |
                                         | 1 1 |

Собираем вместе (4×4):
F⊗F = | 1 0 | 0 0 |     ← верхняя строка блоков: [1&middot;F, 0&middot;F]
      | 1 1 | 0 0 |
      |-----|-----|
      | 1 0 | 1 0 |     ← нижняя строка блоков: [1&middot;F, 1&middot;F]
      | 1 1 | 1 1 |</div>
    <p>
      Каждый следующий уровень удваивает размер: F<sup>&otimes;2</sup> = 4&times;4, F<sup>&otimes;3</sup> = 8&times;8, и т.д.
      Для N = 8 нужно F<sup>&otimes;3</sup> = F &otimes; F &otimes; F.
    </p>
    <p>
      <strong>Зачем это нужно?</strong> Кодирование = умножение вектора входных битов u на матрицу G = F<sup>&otimes;n</sup>:
      <code>x = u &times; G (mod 2)</code>. Каждый выходной бит — XOR определённого набора входных битов.
      Структура Кронекера обеспечивает рекурсивное «перемешивание» (поляризацию) каналов.
    </p>
  </div>

  <div class="explainer">
    <h4>Что такое butterfly-диаграмма?</h4>
    <p>
      Butterfly (бабочка) — это визуализация процесса кодирования. Вместо умножения на большую матрицу
      мы видим <strong>последовательные этапы</strong> попарных XOR-операций:
    </p>
    <ul>
      <li>На каждом этапе пары битов соединяются: верхний бит заменяется на XOR двух, нижний остаётся.</li>
      <li>Этапов = log₂(N). Для N=8 — три этапа.</li>
      <li>Это та же операция, что умножение на G, но разложенная на элементарные шаги. Аналог — FFT (быстрое преобразование Фурье) тоже использует butterfly-схему.</li>
    </ul>
  </div>

  <!-- ═══════ STEP 2: Generator Matrix ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">2</div>
      <div class="step-label">Порождающая матрица G<sub>N</sub> = F<sup>⊗n</sup></div>
    </div>

    <p class="section-desc">
      Матрица кодирования — n-кратное произведение Кронекера базовой матрицы
      F = [[1,0],[1,1]]. Для N = {{ N() }}, n = {{ logN() }}.
      Кодовое слово: x = u · G<sub>N</sub> (mod 2).
    </p>

    <div class="matrix-container">
      <div class="gen-matrix">
        @for (row of generatorMatrix(); track $index; let i = $index) {
          <div class="gen-row">
            @for (cell of row; track $index; let j = $index) {
              <div class="matrix-cell" [class.cell-1]="cell === 1" [class.cell-0]="cell === 0">
                {{ cell }}
              </div>
            }
          </div>
        }
      </div>
    </div>
  </section>

  <!-- ═══════ STEP 3: Butterfly Diagram ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">3</div>
      <div class="step-label">Butterfly-диаграмма кодирования</div>
    </div>

    <p class="section-desc">
      Кодирование полярных кодов эквивалентно рекурсивному butterfly-преобразованию.
      На каждом этапе пары битов комбинируются через XOR (⊕). Это аналог FFT-бабочки.
    </p>

    <div class="butterfly-container">
      <svg [attr.viewBox]="'0 0 ' + (butterflyStages().length * 120 + 120) + ' ' + (N() * 40 + 20)" class="butterfly-svg">
        <!-- Input labels -->
        @for (i of range(N()); track i) {
          <text [attr.x]="10" [attr.y]="i * 40 + 30" class="bf-label"
                [class.bf-frozen]="frozenBits().has(i)">
            u{{ i }}{{ frozenBits().has(i) ? '=0' : '' }}
          </text>
          <!-- Horizontal lines through all stages -->
          <line [attr.x1]="50" [attr.y1]="i * 40 + 26"
                [attr.x2]="butterflyStages().length * 120 + 70" [attr.y2]="i * 40 + 26"
                class="bf-wire"/>
        }

        <!-- Stages -->
        @for (stage of butterflyStages(); track $index; let s = $index) {
          @for (pair of stage.pairs; track pair.top + '-' + pair.bottom) {
            <!-- XOR connections -->
            <line [attr.x1]="s * 120 + 80" [attr.y1]="pair.bottom * 40 + 26"
                  [attr.x2]="s * 120 + 80" [attr.y2]="pair.top * 40 + 26"
                  class="bf-cross"/>
            <circle [attr.cx]="s * 120 + 80" [attr.cy]="pair.top * 40 + 26" r="4" class="bf-xor"/>
          }
        }

        <!-- Output labels -->
        @for (i of range(N()); track i) {
          <text [attr.x]="butterflyStages().length * 120 + 80" [attr.y]="i * 40 + 30" class="bf-output">
            x{{ i }}={{ encoded()[i] }}
          </text>
        }
      </svg>
    </div>
  </section>

  <!-- ═══════ STEP 4: Input & Encoding ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">4</div>
      <div class="step-label">Ввод данных и кодирование</div>
    </div>

    <p class="section-desc">
      Информационные биты размещаются в надёжных каналах. Замороженные биты всегда = 0.
    </p>

    <div class="explainer">
      <h4>Как формируется вектор u (вход)?</h4>
      <p>
        Вектор <strong>u</strong> — это входной вектор длины N = {{ N() }}. Он состоит из двух типов позиций:
      </p>
      <ul>
        <li><strong>Замороженные позиции</strong> ({{ frozenBitIndices().join(', ') }}) — всегда равны <strong>0</strong>.
          Это «плохие» каналы с высоким параметром Бхаттачарьи. Декодер <em>заранее знает</em>, что они = 0.</li>
        <li><strong>Информационные позиции</strong> ({{ infoBitIndices().join(', ') }}) — сюда записываются ваши данные (K = {{ K() }} бит).
          Это «хорошие» каналы с низким Z — именно через них передаются полезные данные.</li>
      </ul>
      <div class="example-box">Пример: данные = [{{ infoBits().join(', ') }}], инф. позиции = [{{ infoBitIndices().join(', ') }}]

Строим u (вектор длины {{ N() }}):
@for (line of uExplanation(); track $index) {  {{ line }}
}
Итого u = [{{ inputVector().join(', ') }}]</div>
    </div>

    <div class="explainer">
      <h4>Как из u получается кодовое слово x?</h4>
      <p>
        Кодирование — это умножение вектора u на порождающую матрицу G (mod 2):
      </p>
      <p>
        <code>x = u &times; G (mod 2)</code>
      </p>
      <p>
        Каждый бит x<sub>j</sub> вычисляется как XOR тех позиций u<sub>i</sub>, где G[i][j] = 1.
        Поскольку замороженные биты = 0, они не вносят вклад. Фактически, x определяется
        только информационными битами и соответствующими строками G.
      </p>
      <div class="example-box">Пример: u = [{{ inputVector().join(', ') }}]

Для каждого x[j] берём столбец j матрицы G и XOR-им
те u[i], где G[i][j] = 1 и u[i] = 1:

@for (line of xExplanation(); track $index) {  {{ line }}
}
Итого x = [{{ encoded().join(', ') }}]</div>
    </div>

    <div class="explainer-why">
      <h4>Что отправляется в канал?</h4>
      <p>
        В канал передаётся <strong>только вектор x</strong> ({{ N() }} бит). Вектор u — это внутреннее представление,
        он никуда не отправляется. Получатель принимает зашумлённую версию x (с возможными ошибками)
        и должен <strong>восстановить u</strong> (а значит, и информационные биты).
      </p>
      <p>
        Канал может инвертировать некоторые биты x. Например, если отправлено x = [{{ encoded().join('') }}],
        а получено y = [{{ received().join('') }}] — значит, произошло {{ errorPositions().size }} {{ errorPositions().size === 1 ? 'ошибка' : 'ошибок' }}.
        Декодер (SC или ML) анализирует y и пытается восстановить исходный u.
      </p>
    </div>

    <div class="input-section">
      <div class="input-label">Информационные биты (K = {{ K() }}):</div>
      <div class="bits-row">
        @for (bit of infoBits(); track $index; let i = $index) {
          <div class="bit-input-group">
            <span class="bit-pos-label">u{{ infoBitIndices()[i] }}</span>
            <div class="bit-cell" [class.bit-0]="bit === 0" [class.bit-1]="bit === 1"
                 (click)="toggleInfoBit(i)">
              {{ bit }}
            </div>
          </div>
        }
      </div>
      <div class="action-row">
        <button class="btn btn-sm" (click)="randomInfoBits()">Случайные данные</button>
      </div>
    </div>

    <div class="vectors-section">
      <div class="vector-row">
        <span class="vector-label">u (вход):</span>
        <div class="vector-bits">
          @for (bit of inputVector(); track $index; let i = $index) {
            <span class="v-bit" [class.v-frozen]="frozenBits().has(i)" [class.v-info]="!frozenBits().has(i)">{{ bit }}</span>
          }
        </div>
      </div>
      <div class="vector-row">
        <span class="vector-label">x (код):</span>
        <div class="vector-bits">
          @for (bit of encoded(); track $index) {
            <span class="v-bit v-encoded">{{ bit }}</span>
          }
        </div>
      </div>
    </div>
  </section>

  <!-- ═══════ Explainer: SC-декодирование ═══════ -->
  <div class="explainer-why">
    <h4>Как работает SC-декодирование? Пошаговый разбор</h4>
    <p>
      <strong>SC</strong> (Successive Cancellation — последовательное исключение) — базовый декодер полярных кодов.
      Его принцип прост: биты декодируются <strong>строго по порядку</strong>, от u<sub>0</sub> до u<sub>N-1</sub>.
    </p>
  </div>

  <div class="explainer">
    <h4>Алгоритм SC — шаг за шагом</h4>
    <p>Для каждого бита u<sub>i</sub> (по порядку):</p>
    <ul>
      <li><strong>Если u<sub>i</sub> — замороженный</strong> → сразу выдаём 0 (мы <em>знаем</em>, что он = 0). Переходим к следующему биту.</li>
      <li><strong>Если u<sub>i</sub> — информационный</strong> → вычисляем LLR на основе:
        <ul>
          <li>Принятого сигнала от канала (наблюдения y<sub>0</sub>..y<sub>N-1</sub>)</li>
          <li>Всех <strong>уже декодированных</strong> битов u<sub>0</sub>..u<sub>i-1</sub></li>
        </ul>
        Если LLR &ge; 0, решаем <code>u<sub>i</sub> = 0</code>; иначе — <code>u<sub>i</sub> = 1</code>.
      </li>
    </ul>
    <div class="example-box">Пример SC-декодирования для N=8, K=4:

u0: замороженный → u0 = 0 (известно)
u1: замороженный → u1 = 0 (известно)
u2: замороженный → u2 = 0 (известно)
u3: замороженный → u3 = 0 (известно)
u4: информационный → LLR = +2.3 ≥ 0 → u4 = 0
u5: информационный → LLR = −1.7 &lt; 0 → u5 = 1
u6: информационный → LLR = +4.1 ≥ 0 → u6 = 0
u7: информационный → LLR = −0.8 &lt; 0 → u7 = 1

Декодированные данные: u4=0, u5=1, u6=0, u7=1</div>
    <p>
      <strong>Почему это работает?</strong> Каждый последующий бит декодируется <strong>точнее</strong>,
      потому что учитывает информацию от всех предыдущих. Замороженные биты в начале дают «бесплатную» информацию,
      помогая декодировать последующие информационные биты. Именно поэтому информационные биты размещаются
      в самых надёжных каналах (с наименьшим Z) — к моменту их декодирования уже накоплено много контекста.
    </p>
    <p>
      <strong>Недостаток SC:</strong> ошибка в одном бите «распространяется» на все последующие (эффект домино).
      Улучшенная версия <strong>SCL</strong> (SC-List) держит несколько «кандидатов» параллельно и выбирает лучший с помощью CRC-проверки.
    </p>
  </div>

  <!-- ═══════ STEP 5: Error Injection ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">5</div>
      <div class="step-label">Канал с ошибками + декодирование</div>
    </div>

    <p class="section-desc">
      Внесите ошибки кликом по битам. Сравните два декодера: SC (последовательный, быстрый, но слабый на коротких кодах)
      и ML (перебор всех кодовых слов — оптимальный для N = {{ N() }}).
    </p>

    <div class="bits-row">
      @for (bit of received(); track $index; let i = $index) {
        <div class="bit-cell"
             [class.bit-error]="isError(i)"
             [class.bit-0]="!isError(i) && bit === 0"
             [class.bit-1]="!isError(i) && bit === 1"
             (click)="toggleError(i)">
          {{ bit }}
        </div>
      }
    </div>

    <div class="action-row">
      <button class="btn btn-danger btn-sm" (click)="randomError(1)">1 ошибка</button>
      <button class="btn btn-danger btn-sm" (click)="randomError(2)">2 ошибки</button>
      <button class="btn btn-danger btn-sm" (click)="randomError(3)">3 ошибки</button>
      <button class="btn btn-sm" (click)="clearErrors()">Убрать ошибки</button>
      <span class="error-count">Ошибок: {{ errorPositions().size }}</span>
    </div>

    <!-- Decoder selector -->
    <div class="decoder-select">
      <span class="decoder-label">Декодер:</span>
      <div class="toggle-group">
        <button class="toggle-btn" [class.active]="decoderType() === 'sc'" (click)="setDecoder('sc')">
          SC (последовательный)
        </button>
        <button class="toggle-btn" [class.active]="decoderType() === 'ml'" (click)="setDecoder('ml')">
          ML (оптимальный)
        </button>
      </div>
    </div>

    <!-- Both decoder results side by side -->
    <div class="decoders-comparison">
      <div class="decoder-result" [class.decoder-active]="decoderType() === 'sc'">
        <div class="decoder-header">
          <span class="decoder-name">SC-декодер</span>
          <span class="decoder-status" [class.ok]="decodingSuccessSC()" [class.fail]="!decodingSuccessSC()">
            {{ decodingSuccessSC() ? '✓' : '✗' }}
          </span>
        </div>
        <div class="decoder-bits">{{ decodedInfoBitsSC().join('') }}</div>
        <div class="decoder-note">Быстрый, O(N log N), но ошибки «каскадируют»</div>
      </div>
      <div class="decoder-result" [class.decoder-active]="decoderType() === 'ml'">
        <div class="decoder-header">
          <span class="decoder-name">ML-декодер</span>
          <span class="decoder-status" [class.ok]="decodingSuccessML()" [class.fail]="!decodingSuccessML()">
            {{ decodingSuccessML() ? '✓' : '✗' }}
          </span>
        </div>
        <div class="decoder-bits">{{ decodedInfoBitsML().join('') }}</div>
        <div class="decoder-note">Оптимальный, O(2<sup>K</sup>), перебор всех кодовых слов</div>
      </div>
    </div>

    <div class="result-comparison">
      <div class="result-row">
        <span class="result-label">Отправлено:</span>
        <code class="result-bits">{{ encoded().join('') }}</code>
      </div>
      <div class="result-row">
        <span class="result-label">Получено:</span>
        <code class="result-bits" [class.error-text]="errorPositions().size > 0">{{ received().join('') }}</code>
      </div>
      <div class="result-row">
        <span class="result-label">Оригинал:</span>
        <code class="result-bits">{{ infoBits().join('') }}</code>
      </div>
      <div class="result-row">
        <span class="result-label">Декодировано:</span>
        <code class="result-bits" [class.ok-text]="decodingSuccess()" [class.error-text]="!decodingSuccess()">{{ decodedInfoBits().join('') }}</code>
      </div>
    </div>
  </section>

  <!-- ═══════ Theory ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">i</div>
      <div class="step-label">Теоретическая справка</div>
    </div>

    <div class="theory-grid">
      <div class="theory-block">
        <h3>Параметры кода</h3>
        <div class="param-list">
          <div class="param"><span class="param-key">N (длина блока)</span><span class="param-val">{{ N() }}</span></div>
          <div class="param"><span class="param-key">K (инф. битов)</span><span class="param-val">{{ K() }}</span></div>
          <div class="param"><span class="param-key">n = log₂(N)</span><span class="param-val">{{ logN() }}</span></div>
          <div class="param"><span class="param-key">Скорость R</span><span class="param-val">{{ (K() / N()).toFixed(2) }}</span></div>
          <div class="param"><span class="param-key">Замороженных</span><span class="param-val">{{ N() - K() }}</span></div>
        </div>
      </div>

      <div class="theory-block">
        <h3>Поляризация — математическая интуиция</h3>
        <p class="theory-text">
          При N → &infin; доля каналов с Z(W) → 0 стремится к пропускной способности I(W),
          а доля каналов с Z(W) → 1 стремится к 1 − I(W).
          Промежуточных каналов становится исчезающе мало — это и есть поляризация.
        </p>
        <p class="theory-text" style="margin-top:12px">
          Ключевой факт: на каждом уровне рекурсии «плохой» канал получает Z<sup>-</sup> = 2Z − Z<sup>2</sup> (хуже),
          а «хороший» — Z<sup>+</sup> = Z<sup>2</sup> (лучше). Поскольку Z &isin; [0,1], возведение в квадрат
          быстро гонит значение к 0 (хорошие каналы), а формула 2Z − Z<sup>2</sup> гонит к 1 (плохие).
          Через log<sub>2</sub>(N) уровней почти все каналы оказываются у полюсов.
        </p>
      </div>

      <div class="theory-block">
        <h3>Алгоритмы декодирования</h3>
        <div class="capability-list">
          <div class="capability ok-cap">SC — Successive Cancellation (базовый)</div>
          <div class="capability ok-cap">SCL — SC List (с CRC-aided)</div>
          <div class="capability ok-cap">BP — Belief Propagation</div>
          <div class="capability ok-cap">SCAN — Soft Cancellation</div>
        </div>
      </div>

      <div class="theory-block">
        <h3>Применения</h3>
        <div class="capability-list">
          <div class="capability ok-cap">5G NR — управляющие каналы (PDCCH, PUCCH)</div>
          <div class="capability ok-cap">Huawei, Qualcomm, Samsung — аппаратные декодеры</div>
          <div class="capability ok-cap">Исследования: квантовые коды коррекции</div>
        </div>
      </div>
    </div>
  </section>
</div>
