<div class="page animate-fade-in">
  <div class="page-header">
    <span class="badge badge-cyan">LDPC</span>
    <h1 class="page-title">LDPC-коды</h1>
    <p class="page-desc">
      Low-Density Parity-Check — линейные коды с разреженной проверочной матрицей.
      Изобретены Робертом Галлагером в 1962, заново открыты в 1996. Декодируются итеративно
      алгоритмом Belief Propagation через граф Таннера. Приближаются к пределу Шеннона.
    </p>
  </div>

  <!-- ═══════ Explainer: Простыми словами ═══════ -->
  <div class="explainer">
    <h4>Простыми словами — что такое LDPC?</h4>
    <p>
      <strong>LDPC</strong> расшифровывается как Low-Density Parity-Check — «проверка чётности с низкой плотностью».
      Давайте разберём каждое слово:
    </p>
    <ul>
      <li><strong>Parity-Check (проверка чётности)</strong> — как в коде Хэмминга: мы проверяем, чтобы XOR определённых битов давал 0.</li>
      <li><strong>Low-Density (низкая плотность)</strong> — каждая проверка затрагивает лишь <strong>несколько</strong> битов из тысяч.
        В отличие от Хэмминга, где каждая проверка покрывает почти половину битов.</li>
    </ul>
    <p>
      <strong>Аналогия:</strong> Представьте класс из 100 учеников. Учитель задал задачу, и каждый получил ответ.
      Вместо того чтобы проверять каждого по одному, учитель разбивает класс на маленькие группы по 3-4 человека.
      Внутри группы ученики сверяют ответы между собой. Если у кого-то ответ не совпадает — его можно исправить
      голосованием соседей. Через несколько раундов таких обсуждений все ошибки исправляются.
    </p>
    <p>
      Именно так работает LDPC: биты «обсуждают» свои значения с соседями через итеративный обмен сообщениями.
      С каждым раундом уверенность растёт, пока все ошибки не исправятся.
    </p>
  </div>

  <div class="explainer">
    <h4>Чем LDPC отличается от Хэмминга и RS?</h4>
    <ul>
      <li><strong>Хэмминг</strong> — простой, исправляет 1 ошибку, декодирование мгновенное (один проход).</li>
      <li><strong>Рид-Соломон</strong> — работает с байтами, исправляет пакетные ошибки, декодирование алгебраическое (формулы).</li>
      <li><strong>LDPC</strong> — работает с битами, исправляет <strong>много</strong> ошибок, декодирование <strong>итеративное</strong> (множество проходов).
        Качество исправления — <strong>лучшее в мире</strong>, почти на теоретическом пределе.</li>
    </ul>
    <p>
      LDPC используется в самых требовательных стандартах: Wi-Fi 6/7, 5G, спутниковое ТВ, SSD-диски.
    </p>
  </div>

  <div class="explainer-why">
    <h4>Что такое предел Шеннона? Объяснение с нуля</h4>
    <p>
      В 1948 году математик <strong>Клод Шеннон</strong> доказал одну из самых важных теорем в истории:
    </p>
    <p>
      <strong>Теорема:</strong> Для любого канала связи (проводного, беспроводного, оптического — любого!) существует число C,
      называемое <strong>пропускной способностью</strong>. Если скорость передачи данных R &lt; C, то <strong>существует</strong>
      код, позволяющий передавать данные со сколь угодно малой вероятностью ошибки. Если R > C — ни один код не поможет.
    </p>
    <div class="example-box">Аналогия: у трубы есть максимальная пропускная способность.
Если вы льёте воду медленнее — всё пройдёт без потерь.
Если быстрее — часть выльется.

C — это «диаметр трубы» для данных.
При R &lt; C можно передавать без ошибок (при правильном коде).
При R > C ошибки неизбежны.</div>
    <p>
      Шеннон доказал, что предел <strong>существует</strong>, но не сказал, <strong>как</strong> построить код, достигающий его.
      Почти 50 лет это оставалось открытой задачей.
    </p>
    <p>
      LDPC-коды (переоткрытые в 1996 году) подошли к пределу Шеннона на расстояние <strong>0.0045 дБ</strong> —
      это менее 0.1% от теоретического максимума! Для сравнения:
    </p>
    <ul>
      <li><strong>Хэмминг(7,4)</strong> — отстаёт на ~3.5 дБ (далеко от предела)</li>
      <li><strong>Турбо-коды</strong> (1993) — ~0.7 дБ (прорыв!)</li>
      <li><strong>LDPC</strong> (1996/2001) — ~0.0045 дБ (практически на пределе)</li>
    </ul>
  </div>

  <!-- ═══════ STEP 1: Parity-Check Matrix ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">1</div>
      <div class="step-label">Разреженная проверочная матрица H</div>
    </div>

    <p class="section-desc">
      Определяющее свойство LDPC — малое число единиц в матрице H. Кликните на ячейку, чтобы переключить значение.
      «Разреженность» означает, что большинство элементов матрицы равны 0.
    </p>

    <div class="explainer">
      <h4>Что такое проверочная матрица H в LDPC?</h4>
      <p>
        Матрица H — таблица из 0 и 1. Каждая <strong>строка</strong> — одно уравнение чётности (проверка).
        Каждый <strong>столбец</strong> — один бит кодового слова. Единица на пересечении означает:
        «этот бит участвует в этой проверке».
      </p>
      <div class="example-box">Пример матрицы H (4 проверки, 8 битов):

     v0 v1 v2 v3 v4 v5 v6 v7
c0 [  0  1  1  1  0  1  0  1 ]  ← проверка c0: v1 ⊕ v2 ⊕ v3 ⊕ v5 ⊕ v7 = 0
c1 [  0  1  1  0  1  0  1  1 ]  ← проверка c1: v1 ⊕ v2 ⊕ v4 ⊕ v6 ⊕ v7 = 0
c2 [  1  0  0  1  0  1  1  1 ]  ← проверка c2: v0 ⊕ v3 ⊕ v5 ⊕ v6 ⊕ v7 = 0
c3 [  1  0  1  1  1  0  1  0 ]  ← проверка c3: v0 ⊕ v2 ⊕ v3 ⊕ v4 ⊕ v6 = 0</div>
    </div>

    <div class="explainer">
      <h4>Почему матрица должна быть разреженной?</h4>
      <p>
        <strong>«Разреженная»</strong> = большинство элементов — нули. В нашем примере: 20 единиц из 32 ячеек = 62% — это ещё <strong>не</strong> разреженная.
        В реальных LDPC: в строке из 10000 элементов единиц будет всего 6-30 (~0.2%). Почему это важно:
      </p>
      <ul>
        <li><strong>Скорость декодирования</strong> — каждая итерация обрабатывает только единицы (рёбра графа). При 0.2% единиц работы в 500 раз меньше, чем для плотной матрицы.</li>
        <li><strong>Качество</strong> — разреженность создаёт <strong>длинные циклы</strong> в графе Таннера.
          Короткие циклы (4, 6) плохи — информация «бегает по кругу» и не приносит новых данных.
          Длинные циклы (≥ 8) означают, что каждое сообщение несёт свежую информацию.</li>
        <li><strong>Масштабируемость</strong> — LDPC-коды работают с блоками из тысяч и миллионов бит. С плотной матрицей декодирование заняло бы годы.</li>
      </ul>
    </div>

    <div class="matrix-container">
      <div class="matrix-interactive">
        <div class="matrix-labels-top">
          <div class="matrix-corner"></div>
          @for (j of range(numVarNodes()); track j) {
            <div class="matrix-col-hdr">v{{ j }}</div>
          }
        </div>
        @for (row of hMatrix(); track $index; let i = $index) {
          <div class="matrix-row-interactive">
            <div class="matrix-row-hdr">c{{ i }}</div>
            @for (cell of row; track $index; let j = $index) {
              <div class="matrix-cell-interactive"
                   [class.cell-one]="cell === 1"
                   [class.cell-zero]="cell === 0"
                   (click)="toggleMatrixCell(i, j)">
                {{ cell }}
              </div>
            }
          </div>
        }
      </div>
    </div>

    <div class="matrix-stats">
      <div class="stat">
        <span class="stat-label">Размерность</span>
        <span class="stat-value">{{ numCheckNodes() }} x {{ numVarNodes() }}</span>
      </div>
      <div class="stat">
        <span class="stat-label">Разреженность</span>
        <span class="stat-value">{{ (sparsity() * 100).toFixed(0) }}%</span>
      </div>
      <div class="stat">
        <span class="stat-label">Скорость R</span>
        <span class="stat-value">{{ codeRate().toFixed(2) }}</span>
      </div>
      <div class="stat">
        <span class="stat-label">Вес строк</span>
        <span class="stat-value mono">{{ rowWeights().join(', ') }}</span>
      </div>
      <div class="stat">
        <span class="stat-label">Вес столбцов</span>
        <span class="stat-value mono">{{ colWeights().join(', ') }}</span>
      </div>
    </div>
  </section>

  <!-- ═══════ STEP 2: Tanner Graph ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">2</div>
      <div class="step-label">Граф Таннера</div>
    </div>

    <p class="section-desc">
      Двудольный граф, представляющий матрицу H. Круги наверху — переменные узлы (биты кодового слова),
      квадраты внизу — проверочные узлы (уравнения чётности). Ребро соединяет v<sub>j</sub> и c<sub>i</sub>,
      если H[i][j] = 1.
    </p>

    <div class="explainer">
      <h4>Что такое граф Таннера?</h4>
      <p>
        Граф Таннера — это <strong>визуальное представление</strong> матрицы H. Вместо таблицы чисел мы рисуем картинку:
      </p>
      <ul>
        <li><strong>Круги наверху (v<sub>0</sub>, v<sub>1</sub>, ...)</strong> — <strong>переменные узлы</strong>. Каждый = один бит кодового слова.</li>
        <li><strong>Квадраты внизу (c<sub>0</sub>, c<sub>1</sub>, ...)</strong> — <strong>проверочные узлы</strong>. Каждый = одно уравнение чётности (одна строка матрицы H).</li>
        <li><strong>Линии (рёбра)</strong> — соединяют бит и проверку, если этот бит участвует в этой проверке (H[i][j] = 1).</li>
      </ul>
      <p>
        Зачем граф? Потому что декодирование — это <strong>обмен сообщениями по рёбрам</strong> графа.
        Каждый узел отправляет соседям информацию о том, каким он «считает» правильное значение.
        Граф наглядно показывает, кто с кем «общается».
      </p>
    </div>

    <div class="tanner-container">
      <svg viewBox="0 0 600 210" class="tanner-svg">
        <!-- Edges -->
        @for (edge of tannerEdges(); track edge.from + edge.to) {
          <line [attr.x1]="edge.x1" [attr.y1]="edge.y1"
                [attr.x2]="edge.x2" [attr.y2]="edge.y2"
                class="tanner-edge"/>
        }
        <!-- Variable nodes (circles) -->
        @for (node of tannerNodes(); track node.id) {
          @if (node.type === 'variable') {
            <circle [attr.cx]="node.x" [attr.cy]="node.y" r="16"
                    class="tanner-var-node"
                    [class.node-error]="isError(+node.id.slice(1))"
                    (click)="toggleError(+node.id.slice(1))"/>
            <text [attr.x]="node.x" [attr.y]="node.y + 1" class="tanner-label">
              {{ node.value }}
            </text>
            <text [attr.x]="node.x" [attr.y]="node.y - 22" class="tanner-name">
              {{ node.label }}
            </text>
          }
          @if (node.type === 'check') {
            <rect [attr.x]="node.x - 14" [attr.y]="node.y - 14" width="28" height="28" rx="4"
                  class="tanner-check-node"/>
            <text [attr.x]="node.x" [attr.y]="node.y + 1" class="tanner-label">+</text>
            <text [attr.x]="node.x" [attr.y]="node.y + 34" class="tanner-name">
              {{ node.label }}
            </text>
          }
        }
      </svg>
    </div>
  </section>

  <!-- ═══════ STEP 3: Error Injection ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">3</div>
      <div class="step-label">Канал с ошибками</div>
    </div>

    <p class="section-desc">
      Кликните на бит кодового слова в графе Таннера (или ниже), чтобы внести ошибку.
      Исходное кодовое слово — все нули. Красные узлы — ошибки.
    </p>

    <div class="bits-row">
      @for (bit of received(); track $index; let i = $index) {
        <div class="bit-cell"
             [class.bit-error]="isError(i)"
             [class.bit-0]="!isError(i) && bit === 0"
             [class.bit-1]="!isError(i) && bit === 1"
             (click)="toggleError(i)">
          {{ bit }}
        </div>
      }
    </div>

    <div class="action-row">
      <button class="btn btn-danger btn-sm" (click)="randomErrors()">Случайные ошибки</button>
      <button class="btn btn-sm" (click)="clearErrors()">Убрать ошибки</button>
      <span class="error-count">Ошибок: {{ errorPositions().size }}</span>
    </div>

    <!-- ═══ Explainer: LLR ═══ -->
    <div class="explainer">
      <h4>Что такое LLR (Log-Likelihood Ratio)? Подробное объяснение</h4>
      <p>
        В отличие от кода Хэмминга, который работает с «жёсткими» решениями (бит = 0 или 1),
        LDPC работает с <strong>«мягкими» решениями</strong> — степенями уверенности. LLR — это число,
        показывающее, <strong>насколько</strong> мы уверены в значении бита.
      </p>
      <p>
        Формула: <code>LLR = ln(P(бит=0) / P(бит=1))</code>, где ln — натуральный логарифм, P — вероятность.
      </p>
      <div class="example-box">Примеры LLR:
  P(бит=0) = 0.99, P(бит=1) = 0.01
  LLR = ln(0.99/0.01) = ln(99) ≈ +4.6   ← очень уверены, что бит = 0

  P(бит=0) = 0.01, P(бит=1) = 0.99
  LLR = ln(0.01/0.99) = ln(0.01) ≈ −4.6  ← очень уверены, что бит = 1

  P(бит=0) = 0.50, P(бит=1) = 0.50
  LLR = ln(0.50/0.50) = ln(1) = 0         ← понятия не имеем (50/50)

  P(бит=0) = 0.70, P(бит=1) = 0.30
  LLR = ln(0.70/0.30) ≈ +0.85             ← слегка склоняемся к 0</div>
      <p><strong>Правило чтения LLR:</strong></p>
      <ul>
        <li><strong>LLR > 0</strong> → скорее всего бит = 0. Чем больше |LLR|, тем увереннее.</li>
        <li><strong>LLR &lt; 0</strong> → скорее всего бит = 1.</li>
        <li><strong>LLR = 0</strong> → полная неопределённость.</li>
        <li><strong>|LLR| > 10</strong> → практически 100% уверенность.</li>
      </ul>
      <p>
        <strong>Зачем логарифм?</strong> При последовательных наблюдениях вероятности нужно <strong>перемножать</strong>.
        Но произведение множества маленьких чисел быстро стремится к 0 (10<sup>-20</sup>, 10<sup>-50</sup>...),
        и компьютер теряет точность. Логарифм превращает умножение в <strong>сложение</strong>:
        ln(a &times; b) = ln(a) + ln(b). Складывать числа вроде −4.6 и +3.2 — легко и точно.
      </p>
    </div>

    <!-- Channel LLRs -->
    <div class="llr-section">
      <div class="llr-label">Канальные LLR (Log-Likelihood Ratio):</div>
      <div class="llr-row">
        @for (llr of channelLLR(); track $index; let i = $index) {
          <div class="llr-cell" [class.llr-positive]="llr > 0" [class.llr-negative]="llr < 0">
            <span class="llr-val">{{ formatLLR(llr) }}</span>
            <span class="llr-pos">v{{ i }}</span>
          </div>
        }
      </div>
      <p class="llr-explain">
        LLR > 0 → вероятнее бит 0; LLR &lt; 0 → вероятнее бит 1. Абсолютное значение — уверенность.
      </p>
    </div>
  </section>

  <!-- ═══════ Explainer: Belief Propagation ═══════ -->
  <div class="explainer-why">
    <h4>Как работает Belief Propagation — пошаговый разбор</h4>
    <p>
      Декодирование LDPC — это <strong>итеративный обмен сообщениями</strong> в графе Таннера.
      На каждой итерации два типа узлов «разговаривают» друг с другом:
    </p>
  </div>

  <div class="explainer">
    <h4>Шаг 1: Инициализация</h4>
    <p>
      Каждый переменный узел v<sub>j</sub> получает начальное значение LLR от канала.
      Например, если канал уверен, что бит = 0, LLR = +5.0. Если уверен, что бит = 1, LLR = −5.0.
      Эти начальные LLR — единственная информация, которой мы располагаем в начале.
    </p>
  </div>

  <div class="explainer">
    <h4>Шаг 2: Check → Variable (проверочный → переменный)</h4>
    <p>
      Каждый проверочный узел c<sub>i</sub> отправляет сообщение каждому своему соседу v<sub>j</sub>.
      Суть сообщения: <em>«Исходя из того, что мне говорят <strong>все остальные</strong> мои соседи, я думаю,
      что ты должен быть ...»</em>.
    </p>
    <div class="example-box">Пример: проверка c0 связана с битами v0, v1, v3.
  c0 → v0: «v1 говорит, что он 0 (LLR=+3), v3 тоже 0 (LLR=+2).
            Чтобы XOR = 0, тебе нужно быть 0 тоже.
            Моя уверенность: min(3, 2) = +2.0»

Формула Min-Sum: знак = произведение знаков остальных,
                 |значение| = минимум |LLR| остальных.</div>
  </div>

  <div class="explainer">
    <h4>Шаг 3: Variable → Check (переменный → проверочный)</h4>
    <p>
      Каждый переменный узел v<sub>j</sub> отправляет сообщение каждому проверочному узлу c<sub>i</sub>.
      Суть: <em>«Я собрал информацию от канала и от <strong>всех остальных</strong> моих проверок (кроме тебя), и вот моё мнение: ...»</em>.
    </p>
    <div class="example-box">Пример: бит v1 связан с проверками c0, c1, c3.
  v1 → c0: канальный LLR (+5.0)
          + сообщение от c1 (+1.5)
          + сообщение от c3 (−0.3)
          = +6.2  ← «я довольно уверен, что я = 0»

  (Сообщение от c0 НЕ включается — чтобы избежать «эха»)</div>
  </div>

  <div class="explainer">
    <h4>Шаг 4: Жёсткое решение и проверка синдрома</h4>
    <p>
      После обмена сообщениями каждый бит обновляет свой <strong>итоговый belief</strong>
      (сумма канального LLR + все сообщения от проверок). Если belief ≥ 0, решаем «0»; иначе — «1».
    </p>
    <p>
      Затем проверяем <strong>синдром</strong>: умножаем полученное слово на матрицу H (mod 2).
      Если все нули — нашли допустимое кодовое слово, декодирование успешно!
      Если нет — повторяем шаги 2-4 (следующая итерация).
    </p>
    <p>
      Обычно хватает 5-50 итераций. Если за максимальное число итераций синдром не обнулился — декодирование провалено.
    </p>
  </div>

  <div class="explainer">
    <h4>Что такое синдром в LDPC?</h4>
    <p>
      Синдром — это вектор <code>S = H &times; c (mod 2)</code>, где c — текущее декодированное слово.
    </p>
    <div class="example-box">Пример (матрица 4×8, слово c = [0, 0, 0, 0, 0, 0, 0, 0]):

s0 = H[0] &middot; c = 0⊕0⊕0⊕0⊕0⊕0⊕0⊕0 = 0 ✓
s1 = H[1] &middot; c = 0 ✓
s2 = H[2] &middot; c = 0 ✓
s3 = H[3] &middot; c = 0 ✓

Если все s = 0 → слово допустимо → декодирование завершено!
Если хоть один s ≠ 0 → ещё есть ошибки → нужна ещё итерация.</div>
  </div>

  <!-- ═══════ STEP 4: Belief Propagation ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">4</div>
      <div class="step-label">Итеративное декодирование (Belief Propagation)</div>
    </div>

    <p class="section-desc">
      Алгоритм Min-Sum: на каждой итерации проверочные и переменные узлы обмениваются
      сообщениями (LLR). Beliefs обновляются, и делается жёсткое решение. Процесс повторяется,
      пока синдром не обнулится или не исчерпаются итерации.
    </p>

    @if (bpIterations().length > 0) {
      <!-- Iteration selector -->
      <div class="iter-selector">
        <span class="iter-label">Итерация:</span>
        <div class="toggle-group">
          @for (iter of bpIterations(); track iter.iteration) {
            <button class="toggle-btn" [class.active]="activeIteration() === iter.iteration - 1"
                    (click)="setActiveIteration(iter.iteration - 1)">
              {{ iter.iteration }}
              @if (iter.syndromeOk) { <span class="iter-ok">&#10003;</span> }
            </button>
          }
        </div>
      </div>

      <!-- Active iteration details -->
      @if (bpIterations()[activeIteration()]; as iter) {
        <div class="iter-details">
          <div class="iter-row">
            <span class="iter-row-label">Beliefs (LLR):</span>
            <div class="llr-row compact">
              @for (b of iter.beliefs; track $index; let i = $index) {
                <div class="llr-cell small" [class.llr-positive]="b > 0" [class.llr-negative]="b < 0">
                  {{ formatLLR(b) }}
                </div>
              }
            </div>
          </div>

          <div class="iter-row">
            <span class="iter-row-label">Декодировано:</span>
            <div class="bits-row compact">
              @for (bit of iter.decoded; track $index; let i = $index) {
                <div class="bit-cell small"
                     [class.bit-corrected]="isError(i) && bit === codeword()[i]"
                     [class.bit-error]="bit !== codeword()[i]"
                     [class.bit-0]="bit === codeword()[i] && bit === 0"
                     [class.bit-1]="bit === codeword()[i] && bit === 1">
                  {{ bit }}
                </div>
              }
            </div>
          </div>

          <div class="iter-status" [class.ok]="iter.syndromeOk" [class.pending]="!iter.syndromeOk">
            @if (iter.syndromeOk) {
              Синдром = 0 — декодирование завершено!
            } @else {
              Синдром ≠ 0 — продолжаем итерации...
            }
          </div>
        </div>
      }
    }
  </section>

  <!-- ═══════ STEP 5: Result ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">5</div>
      <div class="step-label">Результат</div>
    </div>

    <div class="result-message" [class.ok]="finalResult().converged" [class.fail]="!finalResult().converged">
      @if (finalResult().converged) {
        Декодирование успешно за {{ finalResult().iterations }} {{ finalResult().iterations === 1 ? 'итерацию' : 'итераций' }}
      } @else {
        Не сошлось за {{ finalResult().iterations }} из {{ finalResult().maxIter }} итераций
      }
    </div>

    <div class="result-comparison">
      <div class="result-row">
        <span class="result-label">Отправлено:</span>
        <code class="result-bits">{{ codeword().join('') }}</code>
      </div>
      <div class="result-row">
        <span class="result-label">Получено:</span>
        <code class="result-bits" [class.error-text]="errorPositions().size > 0">{{ received().join('') }}</code>
      </div>
      <div class="result-row">
        <span class="result-label">Декодировано:</span>
        <code class="result-bits" [class.ok-text]="finalResult().converged">{{ finalResult().decoded.join('') }}</code>
      </div>
    </div>
  </section>

  <!-- ═══════ Theory ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">i</div>
      <div class="step-label">Теоретическая справка</div>
    </div>

    <div class="theory-grid">
      <div class="theory-block">
        <h3>Что такое «разреженная матрица»?</h3>
        <p class="theory-text">
          В отличие от кодов Хэмминга, где матрица H плотная, в LDPC-кодах
          число единиц в каждой строке и столбце мало относительно размерности.
          Типичные значения: вес столбца d<sub>v</sub> = 3-6, вес строки d<sub>c</sub> = 6-30.
          Это позволяет эффективно декодировать через передачу сообщений.
        </p>
      </div>

      <div class="theory-block">
        <h3>Алгоритмы декодирования</h3>
        <div class="capability-list">
          <div class="capability ok-cap">Sum-Product (точный, сложнее)</div>
          <div class="capability ok-cap">Min-Sum (аппроксимация, быстрее)</div>
          <div class="capability ok-cap">Offset Min-Sum (улучшенный)</div>
          <div class="capability ok-cap">Layered BP (послойная обработка)</div>
        </div>
      </div>

      <div class="theory-block">
        <h3>Применения</h3>
        <div class="capability-list">
          <div class="capability ok-cap">Wi-Fi 6/7 (802.11ax/be)</div>
          <div class="capability ok-cap">5G NR (данные)</div>
          <div class="capability ok-cap">DVB-S2/T2 (спутниковое ТВ)</div>
          <div class="capability ok-cap">10GBASE-T Ethernet</div>
          <div class="capability ok-cap">SSD/Flash-память</div>
        </div>
      </div>

      <div class="theory-block">
        <h3>Предел Шеннона — сравнение</h3>
        <p class="theory-text">
          Теоретический максимум скорости безошибочной передачи для данного канала.
          Сравнение кодов по отступу от предела Шеннона (для BER = 10<sup>-5</sup>):
        </p>
        <div class="param-list">
          <div class="param"><span class="param-key">Хэмминг (7,4)</span><span class="param-val">~3.5 дБ</span></div>
          <div class="param"><span class="param-key">Турбо-коды</span><span class="param-val">~0.7 дБ</span></div>
          <div class="param"><span class="param-key">LDPC (длинные)</span><span class="param-val">~0.0045 дБ</span></div>
        </div>
        <p class="theory-text" style="margin-top:12px">
          LDPC-коды — практически на пределе теоретически возможного. Ближе — только бесконечно длинные коды.
        </p>
      </div>
    </div>
  </section>
</div>
