<div class="page animate-fade-in">
  <div class="page-header">
    <span class="badge badge-indigo">Reed-Solomon</span>
    <h1 class="page-title">Код Рида-Соломона</h1>
    <p class="page-desc">
      Недвоичный циклический код, работающий над конечным полем Галуа GF(2<sup>8</sup>).
      В отличие от кода Хэмминга, оперирует символами (байтами), а не отдельными битами,
      что позволяет исправлять пакетные ошибки. Используется в QR-кодах, CD/DVD, DVB, Deep Space Network.
    </p>
  </div>

  <!-- ═══════ Explainer: Зачем нужен RS ═══════ -->
  <div class="explainer">
    <h4>Зачем нужен Рид-Соломон? Проблема кода Хэмминга</h4>
    <p>
      Код Хэмминга работает с <strong>отдельными битами</strong>: одна ошибка = один перевёрнутый бит.
      Но в реальном мире ошибки часто приходят <strong>пачками</strong> (burst-ошибки):
    </p>
    <ul>
      <li><strong>Царапина на CD/DVD</strong> — повреждает тысячи подряд идущих битов.</li>
      <li><strong>Помеха в радиоканале</strong> — гроза или двигатель создаёт импульс, «убивающий» десятки битов.</li>
      <li><strong>Повреждённый сектор на диске</strong> — целый блок данных становится нечитаемым.</li>
    </ul>
    <p>
      Код Хэмминга против пачки из 10 ошибок бессилен — он рассчитан только на 1 ошибку.
    </p>
    <p>
      <strong>Рид-Соломон</strong> решает эту проблему элегантно: он работает не с битами, а с <strong>байтами</strong> (символами по 8 бит).
      Один повреждённый байт считается <strong>одной ошибкой</strong>, независимо от того, сколько битов в нём испорчено — хоть все 8.
    </p>
    <div class="example-box">Пример: пачка из 16 подряд битовых ошибок

Для Хэмминга: 16 ошибок → невозможно исправить

Для RS: 16 бит = 2 байта максимум → всего 2 символьные ошибки
         RS с t=2 легко это исправит!</div>
    <p>
      Именно поэтому RS используется там, где ошибки приходят пачками: CD/DVD, QR-коды, цифровое ТВ, космическая связь.
    </p>
  </div>

  <div class="explainer">
    <h4>Что такое систематическое кодирование?</h4>
    <p>
      Существует два подхода к кодированию:
    </p>
    <ul>
      <li><strong>Несистематическое</strong> — данные «перемешиваются» с проверочной информацией. Чтобы прочитать исходное сообщение, нужен декодер.</li>
      <li><strong>Систематическое</strong> — исходные данные остаются <strong>в неизменном виде</strong> в начале кодового слова. К ним просто <strong>дописываются</strong> проверочные символы в конец.</li>
    </ul>
    <div class="example-box">Систематическое кодирование:
Сообщение:    [H] [i]              ← исходные данные
Кодовое слово: [H] [i] [✓] [✓] [✓] [✓]  ← данные + проверочные символы

Даже без декодера видно, что сообщение = "Hi"</div>
    <p>
      RS обычно использует систематическое кодирование — это удобнее на практике.
    </p>
  </div>

  <div class="explainer">
    <h4>Ключевые термины RS</h4>
    <ul>
      <li><strong>Символ</strong> — в RS это не бит, а <strong>байт</strong> (8 бит, значение от 0 до 255). Каждый символ — один элемент поля GF(256).</li>
      <li><strong>RS(n, k)</strong> — код с длиной кодового слова n символов, из которых k — данные, а n−k — проверочные.</li>
      <li><strong>t = (n−k)/2</strong> — максимальное число символьных ошибок, которые код может исправить.</li>
      <li><strong>Полином</strong> (многочлен) — выражение вида a<sub>0</sub> + a<sub>1</sub>x + a<sub>2</sub>x<sup>2</sup> + ...
        RS представляет данные как полиномы и выполняет над ними арифметику.</li>
    </ul>
  </div>

  <!-- ═══════ STEP 1: Input ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">1</div>
      <div class="step-label">Входное сообщение</div>
    </div>

    <p class="section-desc">
      Введите текст. Каждый символ будет представлен как элемент поля GF(2<sup>8</sup>) — байт от 0x00 до 0xFF.
    </p>

    <div class="input-group">
      <label class="input-label">Сообщение:</label>
      <input class="input" type="text" [value]="messageInput()" (input)="onMessageInput($event)" placeholder="Введите текст...">
    </div>

    <div class="config-row">
      <div class="config-item">
        <label class="input-label">Символов коррекции (2t):</label>
        <div class="toggle-group">
          @for (n of [2,4,6,8]; track n) {
            <button class="toggle-btn" [class.active]="nSymbols() === n" (click)="setNSymbols(n)">{{ n }}</button>
          }
        </div>
      </div>
      <div class="config-item">
        <span class="badge badge-cyan">Макс. ошибок: {{ maxErrors() }}</span>
      </div>
    </div>

    <!-- Message bytes display -->
    <div class="bytes-section">
      <div class="bytes-label">Байты сообщения:</div>
      <div class="bytes-row">
        @for (byte of messageBytes(); track $index; let i = $index) {
          <div class="byte-cell">
            <span class="byte-char">{{ messageInput()[i] }}</span>
            <span class="byte-hex">{{ toHex(byte) }}</span>
            <span class="byte-pos">{{ i }}</span>
          </div>
        }
      </div>
    </div>
  </section>

  <!-- ═══════ Explainer: Конечное поле ═══════ -->
  <div class="explainer">
    <h4>Что такое конечное поле (поле Галуа)? Объяснение с нуля</h4>
    <p>
      В обычной математике, если мы умножим 200 &times; 200 = 40000 — результат вышел за пределы одного байта (максимум 255).
      Для кодов коррекции это катастрофа: нам нужно, чтобы результат <strong>всегда</strong> помещался в один байт.
    </p>
    <p>
      <strong>Конечное поле GF(256)</strong> — это специальная арифметика для 256 элементов (числа от 0 до 255 = все значения одного байта),
      в которой сложение, вычитание, умножение и деление <strong>всегда дают результат от 0 до 255</strong>.
    </p>
    <p><strong>Сложение в GF(256):</strong></p>
    <p>
      Сложение = <strong>XOR</strong> (побитовое «исключающее ИЛИ»). Это самая быстрая операция в компьютере.
      Важное свойство: вычитание тоже = XOR! (потому что a &oplus; a = 0 для любого a).
    </p>
    <div class="example-box">Сложение в GF(256):
  5 ⊕ 3 = 0000 0101 ⊕ 0000 0011 = 0000 0110 = 6
  7 ⊕ 7 = 0000 0111 ⊕ 0000 0111 = 0000 0000 = 0  (любое число ⊕ само себя = 0)

В обычной математике: 5 + 3 = 8. В GF(256): 5 ⊕ 3 = 6. Другая арифметика!</div>
    <p><strong>Умножение в GF(256):</strong></p>
    <p>
      Умножение сложнее: каждое число представляется как <strong>многочлен</strong> (полином) с двоичными коэффициентами.
      Например, 13 = 1101₂ = x<sup>3</sup> + x<sup>2</sup> + 1. Многочлены перемножаются по обычным правилам,
      но если результат «выходит за 8 бит» (степень ≥ 8), берётся остаток от деления на специальный полином.
    </p>
    <p>
      На практике умножение делается через <strong>таблицы логарифмов</strong>: для каждого числа заранее
      вычислен его логарифм и антилогарифм. Умножение a &times; b = antilog(log(a) + log(b)). Это очень быстро.
    </p>
  </div>

  <div class="explainer-why">
    <h4>Примитивный полином — «правило заворачивания»</h4>
    <p>
      <strong>Примитивный полином</strong> <code>p(x) = x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + 1</code> —
      это «правило заворачивания», которое не даёт числам выйти за 255.
    </p>
    <p>
      Аналогия: представьте циферблат часов. После 12 идёт снова 1 — числа «заворачиваются».
      В GF(256) вместо деления на 12 мы берём остаток от деления на p(x). Результат всегда 0..255.
    </p>
    <p>
      Не любой полином подходит! <code>p(x)</code> должен быть <strong>неприводимым</strong> (нельзя разложить на множители) —
      это аналог простого числа. Стандартный выбор для GF(256): <code>0x11D = 100011101₂</code>.
    </p>
  </div>

  <div class="explainer-why">
    <h4>Примитивный элемент &alpha; = 2 — «генератор» поля</h4>
    <p>
      <strong>&alpha; = 2</strong> — особый элемент поля. Если возводить его в последовательные степени:
    </p>
    <div class="example-box">&alpha;¹ = 2
&alpha;² = 4
&alpha;³ = 8
&alpha;⁴ = 16
...
&alpha;⁷ = 128
&alpha;⁸ = 29  (256 «завернулось» через p(x))
...
&alpha;²⁵⁴ = 142
&alpha;²⁵⁵ = 1  (цикл замкнулся!)</div>
    <p>
      Мы получим <strong>все 255 ненулевых элементов</strong> поля GF(256) — каждый ровно один раз!
      Это как шестерёнка, которая при вращении проходит через все зубья.
    </p>
    <p>
      Зачем это нужно? Порождающий полином RS строится из степеней &alpha;, и весь алгоритм декодирования
      основан на подстановке степеней &alpha; в полиномы. Без генератора поля RS не работает.
    </p>
  </div>

  <!-- ═══════ STEP 2: GF Arithmetic ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">2</div>
      <div class="step-label">Арифметика поля Галуа GF(2<sup>8</sup>)</div>
    </div>

    <p class="section-desc">
      Все операции в коде Рида-Соломона выполняются в конечном поле GF(2<sup>8</sup>) = GF(256).
      Поле строится как GF(2)[x] / (x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + 1).
      Сложение — XOR, умножение — через таблицы логарифмов. Ниже — фрагмент таблицы умножения:
    </p>

    <div class="matrix-container">
      <table class="data-table gf-table">
        <thead>
          <tr>
            <th>*</th>
            @for (j of range(8); track j) {
              <th>{{ j }}</th>
            }
          </tr>
        </thead>
        <tbody>
          @for (row of gfMulTable(); track $index; let i = $index) {
            <tr>
              <td class="row-header">{{ i }}</td>
              @for (cell of row; track $index) {
                <td [class.cell-zero]="cell === 0">{{ cell }}</td>
              }
            </tr>
          }
        </tbody>
      </table>
    </div>

    <div class="gf-info">
      <div class="gf-fact">
        <strong>Примитивный полином:</strong>
        <code>p(x) = x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + 1</code>
        <span class="mono">(0x11D)</span>
      </div>
      <div class="gf-fact">
        <strong>Примитивный элемент:</strong> α = 2 (генератор мультипликативной группы)
      </div>
      <div class="gf-fact">
        <strong>Порядок группы:</strong> 255 (α<sup>255</sup> = 1)
      </div>
    </div>
  </section>

  <!-- ═══════ Explainer: Как устроено кодирование RS ═══════ -->
  <div class="explainer">
    <h4>Как устроено кодирование RS? Пошаговое объяснение</h4>
    <p>
      <strong>Шаг 1: Сообщение → полином.</strong> Каждый байт сообщения становится коэффициентом полинома.
    </p>
    <div class="example-box">Сообщение "Hi" → байты [72, 105]
Полином сообщения: m(x) = 72x + 105
  (72 — коэффициент при x¹, 105 — свободный член)</div>
    <p>
      <strong>Шаг 2: Сдвигаем полином.</strong> Умножаем m(x) на x<sup>2t</sup>, чтобы «освободить место» для проверочных символов в конце.
    </p>
    <div class="example-box">Если 2t = 4 (4 проверочных символа):
m(x) &middot; x⁴ = 72x⁵ + 105x⁴
  (сдвинули на 4 позиции → внизу 4 «пустых» места)</div>
    <p>
      <strong>Шаг 3: Делим на порождающий полином.</strong> Берём <strong>остаток</strong> от деления m(x)&middot;x<sup>2t</sup> на g(x).
      Деление полиномов — как деление чисел «в столбик», только с арифметикой GF(256).
    </p>
    <p>
      <strong>Шаг 4: Дописываем остаток.</strong> Остаток — это проверочные символы. Кодовое слово = m(x)&middot;x<sup>2t</sup> &oplus; остаток.
    </p>
    <div class="example-box">Кодовое слово = [72, 105, r₃, r₂, r₁, r₀]
                   данные    проверочные символы</div>
    <p>
      <strong>Почему это работает?</strong> По построению, кодовое слово делится на g(x) <strong>нацело</strong> (остаток = 0).
      Если при передаче хоть один байт изменился, деление даст ненулевой остаток → ошибка обнаружена!
    </p>
  </div>

  <div class="explainer-why">
    <h4>Что такое порождающий полином g(x)?</h4>
    <p>
      Порождающий полином — «сердце» кода RS. Он строится из последовательных степеней &alpha;:
    </p>
    <div class="example-box">Для 2t = 4 проверочных символов:
g(x) = (x − &alpha;⁰)(x − &alpha;¹)(x − &alpha;²)(x − &alpha;³)

Помним: в GF(256) вычитание = XOR = сложение, поэтому:
g(x) = (x ⊕ 1)(x ⊕ 2)(x ⊕ 4)(x ⊕ 8)

Перемножаем (в арифметике GF!) и получаем полином 4-й степени.</div>
    <p>
      Ключевое свойство: <code>&alpha;<sup>0</sup>, &alpha;<sup>1</sup>, ..., &alpha;<sup>2t-1</sup></code> — <strong>корни</strong> g(x).
      Это значит, что g(&alpha;<sup>i</sup>) = 0 для i = 0, 1, ..., 2t-1.
      Поскольку кодовое слово делится на g(x), оно тоже обращается в 0 при подстановке этих значений.
      Это свойство используется при проверке на ошибки (вычисление синдромов).
    </p>
  </div>

  <!-- ═══════ STEP 3: Generator Polynomial ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">3</div>
      <div class="step-label">Порождающий полином</div>
    </div>

    <p class="section-desc">
      Порождающий полином g(x) определяет код. Для RS(n, k) с 2t символами коррекции:
      g(x) = (x − α<sup>0</sup>)(x − α<sup>1</sup>)...(x − α<sup>2t−1</sup>).
      Корни g(x) — последовательные степени примитивного элемента.
    </p>

    <div class="poly-display">
      <div class="poly-label">g(x) для 2t = {{ nSymbols() }}:</div>
      <code class="poly-value">{{ formatPoly(generatorPoly()) }}</code>
    </div>

    <div class="poly-coeffs">
      <span class="poly-coeffs-label">Коэффициенты (hex):</span>
      <div class="coeffs-row">
        @for (c of generatorPoly(); track $index) {
          <span class="coeff-badge">{{ toHex(c) }}</span>
        }
      </div>
    </div>
  </section>

  <!-- ═══════ STEP 4: Encoding ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">4</div>
      <div class="step-label">Кодирование</div>
    </div>

    <p class="section-desc">
      Систематическое кодирование: сообщение остаётся в начале, к нему дописываются {{ nSymbols() }}
      символов коррекции (остаток от деления m(x)·x<sup>2t</sup> на g(x)).
    </p>

    <div class="encoded-display">
      @for (byte of encoded(); track $index; let i = $index) {
        <div class="byte-cell" [class.byte-data]="i < messageBytes().length" [class.byte-parity]="i >= messageBytes().length">
          <span class="byte-hex">{{ toHex(byte) }}</span>
          <span class="byte-pos">{{ i }}</span>
          <span class="byte-type">{{ i < messageBytes().length ? 'дан.' : 'корр.' }}</span>
        </div>
      }
    </div>
  </section>

  <!-- ═══════ STEP 5: Error Injection ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">5</div>
      <div class="step-label">Инъекция ошибок</div>
    </div>

    <p class="section-desc">
      Кликните на байты, чтобы внести ошибки (инвертируются все биты байта).
      Можно внести до {{ maxErrors() }} ошибок. Красные — повреждённые байты.
    </p>

    <div class="encoded-display">
      @for (byte of received(); track $index; let i = $index) {
        <div class="byte-cell" [class.byte-error]="isErrorPosition(i)"
             [class.byte-data]="!isErrorPosition(i) && i < messageBytes().length"
             [class.byte-parity]="!isErrorPosition(i) && i >= messageBytes().length"
             (click)="toggleError(i)">
          <span class="byte-hex">{{ toHex(byte) }}</span>
          <span class="byte-pos">{{ i }}</span>
        </div>
      }
    </div>

    <div class="action-row">
      <button class="btn btn-danger btn-sm" (click)="randomErrors()">Случайные ошибки</button>
      <button class="btn btn-sm" (click)="clearErrors()">Убрать ошибки</button>
      <span class="error-count">
        Ошибок: {{ errorPositions().size }} / {{ maxErrors() }}
      </span>
    </div>
  </section>

  <!-- ═══════ Explainer: Синдромы в RS ═══════ -->
  <div class="explainer">
    <h4>Что такое синдромы в RS? Пошаговое объяснение</h4>
    <p>
      Синдромы — это <strong>«анализ крови»</strong> для принятого сообщения. Они показывают, здорово ли оно.
    </p>
    <p>
      <strong>Как вычисляются:</strong> мы подставляем в принятый полином r(x) значения
      <code>&alpha;<sup>0</sup>=1, &alpha;<sup>1</sup>=2, ..., &alpha;<sup>2t-1</sup></code>
      (это корни порождающего полинома g(x)).
    </p>
    <div class="example-box">S₀ = r(&alpha;⁰) = r(1)   — подставляем x = 1
S₁ = r(&alpha;¹) = r(2)   — подставляем x = 2
S₂ = r(&alpha;²) = r(4)   — подставляем x = 4
S₃ = r(&alpha;³) = r(8)   — подставляем x = 8

Все вычисления в арифметике GF(256)!</div>
    <p>
      <strong>Что означают результаты:</strong>
    </p>
    <ul>
      <li><strong>Все S<sub>i</sub> = 0</strong> → кодовое слово не повреждено (оно делится на g(x) нацело, а значит все корни g(x) — это и корни кодового слова).</li>
      <li><strong>Хоть один S<sub>i</sub> ≠ 0</strong> → есть ошибки! Значения синдромов содержат «зашифрованную» информацию о том, <strong>где</strong> ошибки и <strong>насколько</strong> изменились байты.</li>
    </ul>
    <p>
      Количество синдромов = 2t (число проверочных символов). Это ровно столько уравнений, сколько нужно для нахождения t ошибок (для каждой ошибки: позиция + величина = 2 неизвестных, итого 2t неизвестных).
    </p>
  </div>

  <!-- ═══════ STEP 6: Syndromes ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">6</div>
      <div class="step-label">Вычисление синдромов</div>
    </div>

    <p class="section-desc">
      Синдром S<sub>i</sub> = r(α<sup>i</sup>), где r(x) — принятый полином.
      Если все синдромы равны 0, ошибок нет. Иначе синдромы содержат информацию о позициях и величинах ошибок.
    </p>

    <div class="syndromes-display">
      @for (s of syndromes().slice(1); track $index; let i = $index) {
        <div class="syndrome-cell" [class.syn-zero]="s === 0" [class.syn-nonzero]="s !== 0">
          <span class="syn-name">S<sub>{{ i }}</sub></span>
          <span class="syn-value">{{ toHex(s) }}</span>
        </div>
      }
    </div>

    <div class="syndrome-verdict" [class.ok]="!hasErrors()" [class.error]="hasErrors()">
      @if (!hasErrors()) {
        Все синдромы = 0 — ошибок нет
      } @else {
        Обнаружены ненулевые синдромы — выполняется декодирование
      }
    </div>
  </section>

  <!-- ═══════ Explainer: Три этапа декодирования ═══════ -->
  <div class="explainer-why">
    <h4>Три этапа декодирования RS — подробный разбор</h4>
    <p>
      Декодирование RS — это детективная работа из трёх шагов. У нас есть 2t «улик» (синдромы), и нужно найти: (1) сколько ошибок, (2) где они, (3) насколько каждый байт изменился.
    </p>
  </div>

  <div class="explainer">
    <h4>Этап 1: Берлекэмп-Мэсси — «Сколько ошибок и какой полином их описывает?»</h4>
    <p>
      Алгоритм строит <strong>полином-локатор ошибок</strong> &Lambda;(x). Это полином, чьи корни связаны с позициями ошибок.
    </p>
    <p>
      Суть алгоритма: мы итеративно «подбираем» полином минимальной степени, который согласуется со всеми синдромами.
      Степень полинома = количество ошибок. Если степень &Lambda;(x) = 2, значит ошибок ровно 2.
    </p>
    <p>
      Алгоритм Берлекэмпа-Мэсси работает за O(t<sup>2</sup>) операций в GF(256) — это очень быстро. Альтернатива — алгоритм Евклида — тоже находит &Lambda;(x), но другим путём.
    </p>
  </div>

  <div class="explainer">
    <h4>Этап 2: Поиск Ченя — «Где именно ошибки?»</h4>
    <p>
      У нас есть полином &Lambda;(x), и мы знаем, что его корни указывают на позиции ошибок.
      Нужно найти эти корни.
    </p>
    <p>
      <strong>Метод:</strong> подставляем в &Lambda;(x) все возможные значения &alpha;<sup>-i</sup> для i = 0, 1, ..., n-1.
      Если &Lambda;(&alpha;<sup>-i</sup>) = 0, то позиция i содержит ошибку.
    </p>
    <div class="example-box">Поиск Ченя (Chien search):
  &Lambda;(&alpha;⁰) = 17  ≠ 0 → позиция 0 OK
  &Lambda;(&alpha;⁻¹) = 0   = 0 → ОШИБКА в позиции 1!
  &Lambda;(&alpha;⁻²) = 203 ≠ 0 → позиция 2 OK
  ...и так далее для всех позиций</div>
    <p>
      Это по сути <strong>полный перебор</strong>, но каждая проверка — одна операция. При аппаратной реализации все проверки делаются параллельно за один такт.
    </p>
  </div>

  <div class="explainer">
    <h4>Этап 3: Алгоритм Форни — «На сколько ошибся каждый байт?»</h4>
    <p>
      Мы знаем <strong>где</strong> ошибки (из поиска Ченя). Теперь нужно узнать <strong>насколько</strong> изменился каждый повреждённый байт — <strong>величину ошибки</strong>.
    </p>
    <p>
      Алгоритм Форни вычисляет величину ошибки e<sub>i</sub> по формуле, использующей полином-локатор &Lambda;(x) и полином-оценщик ошибок &Omega;(x).
    </p>
    <p>
      Исправление: <code>правильный_байт = полученный_байт &oplus; e<sub>i</sub></code>.
      XOR с величиной ошибки «отменяет» повреждение.
    </p>
    <div class="example-box">Итоговый пример:
  Получили байт в позиции 3: 0xA7
  Форни вычислил: величина ошибки = 0x15
  Исправленный:   0xA7 ⊕ 0x15 = 0xB2 ← правильное значение!</div>
  </div>

  <!-- ═══════ STEP 7: Decoding Pipeline ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">7</div>
      <div class="step-label">Конвейер декодирования</div>
    </div>

    <p class="section-desc">
      Декодирование RS проходит в три этапа: 1) Алгоритм Берлекэмпа-Мэсси находит полином-локатор ошибок,
      2) Поиск Ченя находит позиции ошибок, 3) Алгоритм Форни вычисляет величины ошибок.
    </p>

    <div class="pipeline">
      @for (step of correctionResult().steps; track $index; let i = $index) {
        <div class="pipeline-step">
          <div class="pipeline-num">{{ i + 1 }}</div>
          <div class="pipeline-content">
            <div class="pipeline-title">{{ step.title }}</div>
            <div class="pipeline-desc">{{ step.description }}</div>
            @if (step.data) {
              <code class="pipeline-data">{{ step.data }}</code>
            }
          </div>
        </div>
      }
    </div>
  </section>

  <!-- ═══════ STEP 8: Result ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">8</div>
      <div class="step-label">Результат</div>
    </div>

    <div class="result-message" [class.ok]="correctionResult().success" [class.fail]="!correctionResult().success">
      {{ correctionResult().message }}
    </div>

    @if (correctionResult().success) {
      <div class="result-comparison">
        <div class="result-row">
          <span class="result-label">Отправлено:</span>
          <code class="result-hex">{{ encoded().map(toHex).join(' ') }}</code>
        </div>
        @if (hasErrors()) {
          <div class="result-row">
            <span class="result-label">Получено:</span>
            <code class="result-hex error-text">{{ received().map(toHex).join(' ') }}</code>
          </div>
          <div class="result-row">
            <span class="result-label">Исправлено:</span>
            <code class="result-hex ok-text">{{ correctionResult().corrected.map(toHex).join(' ') }}</code>
          </div>
        }
        <div class="result-row">
          <span class="result-label">Сообщение:</span>
          <code class="result-text">{{ decodedMessage() }}</code>
        </div>
      </div>
    }
  </section>

  <!-- ═══════ Theory ═══════ -->
  <section class="card section">
    <div class="step-indicator">
      <div class="step-num">i</div>
      <div class="step-label">Теоретическая справка</div>
    </div>

    <div class="theory-grid">
      <div class="theory-block">
        <h3>Параметры кода RS(n, k)</h3>
        <div class="param-list">
          <div class="param"><span class="param-key">n (длина кодового слова)</span><span class="param-val">{{ encoded().length }}</span></div>
          <div class="param"><span class="param-key">k (информ. символов)</span><span class="param-val">{{ messageBytes().length }}</span></div>
          <div class="param"><span class="param-key">2t (символов коррекции)</span><span class="param-val">{{ nSymbols() }}</span></div>
          <div class="param"><span class="param-key">t (макс. ошибок)</span><span class="param-val">{{ maxErrors() }}</span></div>
          <div class="param"><span class="param-key">d<sub>min</sub></span><span class="param-val">{{ nSymbols() + 1 }}</span></div>
          <div class="param"><span class="param-key">Поле</span><span class="param-val">GF(2<sup>8</sup>)</span></div>
        </div>
      </div>

      <div class="theory-block">
        <h3>Граница Синглтона и MDS</h3>
        <p class="theory-text">
          RS-коды являются <strong>MDS-кодами</strong> (Maximum Distance Separable — коды с максимальным расстоянием):
        </p>
        <div class="formula">d<sub>min</sub> = n − k + 1 = 2t + 1</div>
        <p class="theory-text" style="margin-top:12px">
          Граница Синглтона гласит: для <em>любого</em> кода d<sub>min</sub> ≤ n − k + 1.
          RS-коды <strong>достигают</strong> этого теоретического максимума — каждый избыточный символ
          используется оптимально. Ни один бит не «потрачен зря». Именно поэтому RS-коды
          так популярны: они дают наилучшее соотношение избыточности к корректирующей способности.
        </p>
      </div>

      <div class="theory-block">
        <h3>Применения</h3>
        <div class="capability-list">
          <div class="capability ok-cap">QR-коды (4 уровня коррекции)</div>
          <div class="capability ok-cap">CD/DVD/Blu-ray (CIRC)</div>
          <div class="capability ok-cap">DVB-T/S/C (цифровое ТВ)</div>
          <div class="capability ok-cap">Deep Space Network (NASA)</div>
          <div class="capability ok-cap">RAID-6 (два диска чётности)</div>
        </div>
      </div>

      <div class="theory-block">
        <h3>Пакетные vs. одиночные ошибки</h3>
        <p class="theory-text">
          RS-код, исправляющий t символов, может исправить пакет из до t·m = {{ maxErrors() * 8 }} последовательных
          битовых ошибок (m = 8 для GF(2<sup>8</sup>)). Это ключевое преимущество над двоичными кодами.
        </p>
      </div>
    </div>
  </section>
</div>
